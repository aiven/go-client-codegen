//go:build generator

// Package main is the generator of the client code.
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"time"

	"github.com/dave/jennifer/jen"
	"github.com/iancoleman/strcase"
	"github.com/kelseyhightower/envconfig"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"golang.org/x/exp/slices"
	"gopkg.in/yaml.v3"
)

const (
	generatedHeader   = "Code generated by Aiven. DO NOT EDIT."
	configPrefix      = "GEN"
	defaultAPIVersion = "v1"
)

type envConfig struct {
	Module      string `envconfig:"MODULE" default:"github.com/aiven/go-client-codegen"`
	Package     string `envconfig:"PACKAGE" default:"aiven"`
	HandlerDir  string `envconfig:"HANDLER_DIR" default:"handler"`
	ConfigFile  string `envconfig:"CONFIG_FILE" default:"config.yaml"`
	ClientFile  string `envconfig:"CLIENT_FILE" default:"client_generated.go"`
	OpenAPIFile string `envconfig:"OPENAPI_FILE" default:"openapi.json"`
}

var (
	pathClean      = regexp.MustCompile(`\{[^{]+}`)
	pathVersioning = regexp.MustCompile(`^/v[0-9]/`)
)

func main() {
	log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr, TimeFormat: time.RFC3339})

	err := exec()
	if err != nil {
		log.Err(err)
	}
}

// nolint:funlen,gocognit,gocyclo // It's a generator, it's supposed to be long, and we won't expand it.
func exec() error {
	cfg := new(envConfig)

	err := envconfig.Process(configPrefix, cfg)
	if err != nil {
		return err
	}

	config, err := readConfig(cfg.ConfigFile)
	if err != nil {
		return err
	}

	docBytes, err := os.ReadFile(cfg.OpenAPIFile)
	if err != nil {
		return err
	}

	doc := new(Doc)

	err = json.Unmarshal(docBytes, doc)
	if err != nil {
		return err
	}

	pkgs := make(map[string][]*Path)

	for path := range doc.Paths {
		v := doc.Paths[path]
		for meth, p := range v {
			if p.Deprecated {
				continue
			}

			if !pathVersioning.MatchString(path) {
				path = fmt.Sprintf("/%s%s", defaultAPIVersion, path)
			}

			p.Path = path
			p.Method = strings.ToUpper(meth)
			p.ID = p.OperationID

			var pkg string
		outer:
			for k, idList := range config {
				for _, id := range idList {
					if p.ID == id {
						pkg = k

						break outer
					}
				}
			}

			if pkg == "" {
				log.Error().Msgf("%q id not found in config!", p.ID)

				continue
			}

			pkgs[pkg] = append(pkgs[pkg], p)
			params := make([]*Parameter, 0)

			for _, ref := range p.Parameters {
				parts := strings.Split(ref.Ref, "/")
				name := parts[len(parts)-1]

				param, ok := doc.Components.Parameters[name]
				if !ok {
					return fmt.Errorf("param %q not found", ref.Ref)
				}

				if param.In != ParameterInPath {
					log.Printf("%q param %s in %q", p.OperationID, param.Name, param.In)

					continue
				}

				if param.Name == "version_id" {
					param.Schema.Type = SchemaTypeInteger
				}

				param.Ref = ref.Ref
				params = append(params, param)
			}

			p.Parameters = params
		}
	}

	const doerName = "doer"

	ctx := jen.Id("ctx").Qual("context", "Context")
	doer := jen.Type().Id(doerName).Interface(
		jen.Id("Do").Params(
			ctx,
			jen.List(jen.Id("operationID"), jen.Id("method"), jen.Id("path")).String(),
			jen.Id("v").Any(),
		).Parens(jen.List(jen.Index().Byte(), jen.Error())),
	).Line()
	clientFields := make([]jen.Code, 0, len(pkgs))
	clientValues := jen.Dict{}
	clientTypeValues := make([]jen.Code, 0, len(pkgs))

	for _, pkg := range sortedKeys(pkgs) {
		const handlerType = "Handler"

		paths := pkgs[pkg]
		fileName := strings.ToLower(pkg)
		handlerName := pkg + handlerType
		newHandler := "New" + handlerType
		scope := make(map[string]*Schema)

		for _, p := range paths {
			p.FuncName = p.OperationID
		}

		sort.SliceStable(paths, func(i, j int) bool {
			return paths[i].FuncName < paths[j].FuncName
		})

		file := jen.NewFile(fileName)
		file.HeaderComment(generatedHeader)
		handler := file.Type().Id(handlerType)
		file.Func().Id(newHandler).Params(jen.Id(doerName).Id(doerName)).Id(handlerName).Block(
			jen.Return(jen.Id(handlerName).Values(jen.Id(doerName))),
		)
		file.Add(doer)
		file.Type().Id(handlerName).Struct(jen.Id(doerName).Id(doerName))

		var typeMethods []jen.Code

		for _, path := range paths {
			// todo: support 204
			out := path.Out.OK.Content["application/json"]
			if out == nil && path.Out.NoContent.Content == nil {
				log.Printf("%q has no json response. Skipping", path.OperationID)

				continue
			}

			schemas := make([]*Schema, 0)
			params := make([]jen.Code, 0, len(path.Parameters))
			params = append(params, ctx)

			for _, p := range path.Parameters {
				p.Schema.in = true
				p.Schema.required = true
				p.Schema.init(doc, scope, p.Name)
				schemas = append(schemas, p.Schema)
				param := jen.Id(strcase.ToLowerCamel(p.Schema.CamelName)).Add(getType(p.Schema))
				params = append(params, param)
			}

			in := path.In.Content["application/json"]
			if in != nil {
				var schemaIn *Schema

				schemaIn, err = doc.getSchema(in.Schema.Ref)
				if err != nil {
					return err
				}

				schemaIn.in = true

				schemaIn.init(doc, scope, path.FuncName)
				schemas = append(schemas, schemaIn)
				params = append(params, jen.Id("in").Id("*"+schemaIn.CamelName))
			}

			typeMeth := jen.Id(path.FuncName).Params(params...)
			structMeth := jen.Func().Params(jen.Id("h").Id("*" + handlerName)).Id(path.FuncName).Params(params...)

			var rsp, schemaOut *Schema
			if out != nil {
				schemaOut, err = doc.getSchema(out.Schema.Ref)
				if err != nil {
					return err
				}

				schemaOut.out = true

				schemaOut.init(doc, scope, path.FuncName)
				rsp = getResponse(schemaOut)
			}

			// forcePointer Required objects must be returned by a pointer for consistency
			forcePointer := rsp != nil && rsp.required && rsp.isObject()

			if rsp != nil {
				ret := jen.List(getType(rsp), jen.Error())
				if forcePointer {
					// foo() (*Foo, err)
					ret = jen.List(jen.Id("*"+rsp.CamelName), jen.Error())
				}

				typeMeth.Parens(ret)
				structMeth.Parens(ret)
			} else {
				typeMeth.Error()
				structMeth.Error()
			}

			typeMethods = append(typeMethods, path.Comment(), typeMeth.Line())

			paramIndex := -1
			url := pathClean.ReplaceAllStringFunc(path.Path, func(_ string) string {
				paramIndex++

				switch t := path.Parameters[paramIndex].Schema.Type; t {
				case SchemaTypeInteger:
					return "%d"
				case SchemaTypeString:
					return "%s"
				default:
					panic(fmt.Sprintf("%s unexpected parameter type %s", path.OperationID, t))
				}
			})
			urlParams := make([]jen.Code, 0, len(params))
			urlParams = append(urlParams, jen.Lit(url))
			inObj := jen.Nil()

			for _, s := range schemas {
				if s.isObject() {
					inObj = jen.Id("in")

					continue
				}

				v := jen.Id(strcase.ToLowerCamel(s.CamelName))
				if s.Type == SchemaTypeString {
					v = jen.Id("url.PathEscape").Call(v)
				}

				urlParams = append(urlParams, v)
			}

			outObj := jen.Id("_")
			returnErr := jen.Return(jen.Err())

			if rsp != nil {
				outObj = jen.Id("b")

				// In most cases, "nil" is for error return
				// But for required scalars should be zero values
				returnErr = jen.Return(jen.Nil(), jen.Err())

				if rsp.required {
					switch rsp.Type {
					case SchemaTypeString:
						returnErr = jen.Return(jen.Lit(""), jen.Err())
					case SchemaTypeInteger, SchemaTypeNumber:
						returnErr = jen.Return(jen.Lit(0), jen.Err())
					case SchemaTypeBoolean:
						returnErr = jen.Return(jen.False(), jen.Err())
					}
				}
			}

			block := []jen.Code{
				jen.Id("path").Op(":=").Qual("fmt", "Sprintf").Call(urlParams...),
				jen.List(outObj, jen.Err()).Op(":=").Id("h.doer.Do").Call(
					jen.Id("ctx"),
					jen.Lit(path.OperationID),
					jen.Lit(path.Method),
					jen.Id("path"),
					inObj,
				),
			}

			ifErr := jen.If(jen.Err().Op("!=").Nil()).Block(returnErr)

			if rsp == nil {
				block = append(block, jen.Return(jen.Err()))
			} else {
				block = append(block, ifErr)

				outReturn := jen.Id("out")

				if rsp.CamelName != schemaOut.CamelName {
					// Takes original name and turns to camel.
					// "CamelName" field might have been modified because of name collisions
					outReturn.Dot(strcase.ToCamel(rsp.name))

					if forcePointer {
						// return &out.Foo
						outReturn = jen.Id("&").Add(outReturn)
					}
				}

				block = append(
					block,
					jen.Id("out").Op(":=").New(jen.Id(schemaOut.CamelName)),
					jen.Err().Op("=").Qual("encoding/json", "Unmarshal").Call(jen.Id("b"), jen.Id("out")),
					ifErr,
					jen.Return(outReturn, jen.Nil()),
				)
			}

			file.Add(structMeth.Block(block...))
		}

		for _, k := range sortedKeys(scope) {
			v := scope[k]
			err = writeStruct(file, v)

			if err != nil {
				return err
			}
		}

		dirPath := filepath.Join(cfg.HandlerDir, fileName)

		err = os.MkdirAll(dirPath, os.ModePerm)
		if err != nil {
			return err
		}

		handler.Interface(typeMethods...)

		err = file.Save(filepath.Join(dirPath, fileName+".go"))
		if err != nil {
			return err
		}

		pkgName := filepath.Join(cfg.Module, cfg.HandlerDir, fileName)
		clientFields = append(clientFields, jen.Qual(pkgName, handlerName))
		clientValues[jen.Id(handlerName)] = jen.Qual(pkgName, newHandler).Call(jen.Id(doerName))
		clientTypeValues = append(clientTypeValues, jen.Qual(pkgName, handlerType))
	}

	client := jen.NewFile(cfg.Package)
	client.HeaderComment(generatedHeader)
	client.Add(doer)
	client.Func().Id("newClient").Params(jen.Id(doerName).Id(doerName)).Id("Client").Block(
		jen.Return(jen.Id("&client").Values(clientValues)),
	)
	client.Type().Id("client").Struct(clientFields...)
	client.Type().Id("Client").Interface(clientTypeValues...)

	return client.Save(cfg.ClientFile)
}

// reMakesSense sometimes there are invalid enums, for instance just a comma ","
var reMakesSense = regexp.MustCompile(`\w`)

// nolint:funlen // It's a generator, it's supposed to be long, and we won't expand it.
func writeStruct(f *jen.File, s *Schema) error {
	// nolint:nestif // It's a generator, it's supposed to be long, and we won't expand it.
	if s.isEnum() {
		kind := getScalarType(s)
		o := f.Type().Id(s.CamelName)
		o.Add(kind)

		enums := make([]jen.Code, 0)
		values := make([]jen.Code, 0)

		for _, e := range s.Enum {
			literal := fmt.Sprint(e)
			if !reMakesSense.MatchString(literal) {
				continue
			}

			constant := s.CamelName + strcase.ToCamel(literal)

			// KafkaMirror ReplicationPolicyClassType makes bad generated name
			if strings.HasPrefix(literal, "org.apache.kafka.connect.mirror.") {
				constant = s.CamelName + literal[32:len(literal)-17]
			}

			// OpenSearch HealthType has value "red*"
			if strings.HasSuffix(literal, "*") {
				constant += "Asterisk"
			}

			enums = append(enums, jen.Id(constant).Op(s.CamelName).Op("=").Lit(literal))
			values = append(values, jen.Lit(literal))
		}

		if len(enums) == 0 {
			return nil
		}

		o.Line().Const().Defs(enums...)

		o.Line().Func().Id(s.CamelName + "Choices").Params().Index().Add(kind).Block(
			jen.Return(jen.Index().Add(kind).Values(values...)),
		)

		return nil
	}

	fields := make([]jen.Code, 0, len(s.Properties))

	for _, k := range s.propertyNames {
		p := s.Properties[k]
		field := jen.Id(strcase.ToCamel(k)).Add(getType(p))
		tag := k

		if !p.required {
			tag += ",omitempty"
		}

		field = field.Tag(map[string]string{"json": strings.ReplaceAll(tag, `\`, "")})

		// Adds a comment if it's not equal to the field name
		if p.Description != "" && p.Description != p.CamelName {
			field = field.Add(jen.Comment(p.Description))
		}

		fields = append(fields, field)
	}

	if s.Description != "" {
		f.Comment(fmt.Sprintf("%s %s", s.CamelName, s.Description))
	}

	f.Type().Id(s.CamelName).Struct(fields...)

	return nil
}

func getResponse(s *Schema) *Schema {
	switch len(s.Properties) {
	case 1:
		// If the schema has just one field, then uses it as out dto.
		// That makes code simpler.
		return s.Properties[s.propertyNames[0]]
	case 0:
		return nil
	}

	return s
}

func toSingle(src string) string {
	s := strings.TrimSuffix(src, "ies")
	if s != src {
		return s + "y"
	}

	return strings.TrimSuffix(src, "s")
}

const (
	yamlTabSize = 2
	writeMode   = os.FileMode(0644)
)

// readConfig reads and formats the config
func readConfig(path string) (map[string][]string, error) {
	filePath := filepath.Clean(path)

	b, err := os.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	c := make(map[string][]string)

	err = yaml.Unmarshal(b, &c)
	if err != nil {
		return nil, err
	}

	// Updates the config
	for _, v := range c {
		slices.Sort(v)
	}

	var buffer bytes.Buffer
	encoder := yaml.NewEncoder(&buffer)
	encoder.SetIndent(yamlTabSize)

	err = encoder.Encode(&c)
	if err != nil {
		return nil, err
	}

	err = os.WriteFile(filePath, buffer.Bytes(), writeMode)
	if err != nil {
		return nil, err
	}

	return c, nil
}
