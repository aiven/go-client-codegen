// Code generated by Aiven. DO NOT EDIT.

package applicationuser

import (
	"context"
	"encoding/json"
	"fmt"
	"net/url"
	"time"
)

type Handler interface {
	// ApplicationUserAccessTokenCreate create an application token
	// POST /v1/organization/{organization_id}/application-users/{user_id}/access-tokens
	// https://api.aiven.io/doc/#tag/Application_Users/operation/ApplicationUserAccessTokenCreate
	ApplicationUserAccessTokenCreate(ctx context.Context, organizationId string, userId string, in *ApplicationUserAccessTokenCreateIn) (*ApplicationUserAccessTokenCreateOut, error)

	// ApplicationUserAccessTokenDelete delete an application token
	// DELETE /v1/organization/{organization_id}/application-users/{user_id}/access-tokens/{token_prefix}
	// https://api.aiven.io/doc/#tag/Application_Users/operation/ApplicationUserAccessTokenDelete
	ApplicationUserAccessTokenDelete(ctx context.Context, organizationId string, userId string, tokenPrefix string) error

	// ApplicationUserAccessTokensList list application tokens
	// GET /v1/organization/{organization_id}/application-users/{user_id}/access-tokens
	// https://api.aiven.io/doc/#tag/Application_Users/operation/ApplicationUserAccessTokensList
	ApplicationUserAccessTokensList(ctx context.Context, organizationId string, userId string) ([]TokenOut, error)

	// ApplicationUserCreate create an application user
	// POST /v1/organization/{organization_id}/application-users
	// https://api.aiven.io/doc/#tag/Application_Users/operation/ApplicationUserCreate
	ApplicationUserCreate(ctx context.Context, organizationId string, in *ApplicationUserCreateIn) (*ApplicationUserCreateOut, error)

	// ApplicationUserDelete delete an application user
	// DELETE /v1/organization/{organization_id}/application-users/{user_id}
	// https://api.aiven.io/doc/#tag/Application_Users/operation/ApplicationUserDelete
	ApplicationUserDelete(ctx context.Context, organizationId string, userId string) error

	// ApplicationUserGet get an application user
	// GET /v1/organization/{organization_id}/application-users/{user_id}
	// https://api.aiven.io/doc/#tag/Application_Users/operation/ApplicationUserGet
	ApplicationUserGet(ctx context.Context, organizationId string, userId string) (*ApplicationUserGetOut, error)

	// ApplicationUserUpdate update details on an application user of the organization
	// PATCH /v1/organization/{organization_id}/application-users/{user_id}
	// https://api.aiven.io/doc/#tag/Application_Users/operation/ApplicationUserUpdate
	ApplicationUserUpdate(ctx context.Context, organizationId string, userId string, in *ApplicationUserUpdateIn) (*ApplicationUserUpdateOut, error)

	// ApplicationUsersList list application users
	// GET /v1/organization/{organization_id}/application-users
	// https://api.aiven.io/doc/#tag/Application_Users/operation/ApplicationUsersList
	ApplicationUsersList(ctx context.Context, organizationId string) ([]ApplicationUserOut, error)
}

func NewHandler(doer doer) ApplicationUserHandler {
	return ApplicationUserHandler{doer}
}

type doer interface {
	Do(ctx context.Context, operationID, method, path string, v any) ([]byte, error)
}

type ApplicationUserHandler struct {
	doer doer
}

func (h *ApplicationUserHandler) ApplicationUserAccessTokenCreate(ctx context.Context, organizationId string, userId string, in *ApplicationUserAccessTokenCreateIn) (*ApplicationUserAccessTokenCreateOut, error) {
	path := fmt.Sprintf("/v1/organization/%s/application-users/%s/access-tokens", url.PathEscape(organizationId), url.PathEscape(userId))
	b, err := h.doer.Do(ctx, "ApplicationUserAccessTokenCreate", "POST", path, in)
	if err != nil {
		return nil, err
	}
	out := new(ApplicationUserAccessTokenCreateOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *ApplicationUserHandler) ApplicationUserAccessTokenDelete(ctx context.Context, organizationId string, userId string, tokenPrefix string) error {
	path := fmt.Sprintf("/v1/organization/%s/application-users/%s/access-tokens/%s", url.PathEscape(organizationId), url.PathEscape(userId), url.PathEscape(tokenPrefix))
	_, err := h.doer.Do(ctx, "ApplicationUserAccessTokenDelete", "DELETE", path, nil)
	return err
}
func (h *ApplicationUserHandler) ApplicationUserAccessTokensList(ctx context.Context, organizationId string, userId string) ([]TokenOut, error) {
	path := fmt.Sprintf("/v1/organization/%s/application-users/%s/access-tokens", url.PathEscape(organizationId), url.PathEscape(userId))
	b, err := h.doer.Do(ctx, "ApplicationUserAccessTokensList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(applicationUserAccessTokensListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Tokens, nil
}
func (h *ApplicationUserHandler) ApplicationUserCreate(ctx context.Context, organizationId string, in *ApplicationUserCreateIn) (*ApplicationUserCreateOut, error) {
	path := fmt.Sprintf("/v1/organization/%s/application-users", url.PathEscape(organizationId))
	b, err := h.doer.Do(ctx, "ApplicationUserCreate", "POST", path, in)
	if err != nil {
		return nil, err
	}
	out := new(ApplicationUserCreateOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *ApplicationUserHandler) ApplicationUserDelete(ctx context.Context, organizationId string, userId string) error {
	path := fmt.Sprintf("/v1/organization/%s/application-users/%s", url.PathEscape(organizationId), url.PathEscape(userId))
	_, err := h.doer.Do(ctx, "ApplicationUserDelete", "DELETE", path, nil)
	return err
}
func (h *ApplicationUserHandler) ApplicationUserGet(ctx context.Context, organizationId string, userId string) (*ApplicationUserGetOut, error) {
	path := fmt.Sprintf("/v1/organization/%s/application-users/%s", url.PathEscape(organizationId), url.PathEscape(userId))
	b, err := h.doer.Do(ctx, "ApplicationUserGet", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(ApplicationUserGetOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *ApplicationUserHandler) ApplicationUserUpdate(ctx context.Context, organizationId string, userId string, in *ApplicationUserUpdateIn) (*ApplicationUserUpdateOut, error) {
	path := fmt.Sprintf("/v1/organization/%s/application-users/%s", url.PathEscape(organizationId), url.PathEscape(userId))
	b, err := h.doer.Do(ctx, "ApplicationUserUpdate", "PATCH", path, in)
	if err != nil {
		return nil, err
	}
	out := new(ApplicationUserUpdateOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *ApplicationUserHandler) ApplicationUsersList(ctx context.Context, organizationId string) ([]ApplicationUserOut, error) {
	path := fmt.Sprintf("/v1/organization/%s/application-users", url.PathEscape(organizationId))
	b, err := h.doer.Do(ctx, "ApplicationUsersList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(applicationUsersListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.ApplicationUsers, nil
}

// ApplicationUserAccessTokenCreateIn ApplicationUserAccessTokenCreateRequestBody
type ApplicationUserAccessTokenCreateIn struct {
	Description    string    `json:"description"`
	ExtendWhenUsed *bool     `json:"extend_when_used,omitempty"` // Extend token expiration time when token is used. Only applicable if max_age_seconds is specified.
	MaxAgeSeconds  *int      `json:"max_age_seconds,omitempty"`  // Time the token remains valid since creation (or since last use if extend_when_used is true)
	Scopes         *[]string `json:"scopes,omitempty"`           // Scopes this token is restricted to if specified
}

// ApplicationUserAccessTokenCreateOut ApplicationUserAccessTokenCreateResponse
type ApplicationUserAccessTokenCreateOut struct {
	FullToken   string `json:"full_token"`   // Full Token
	TokenPrefix string `json:"token_prefix"` // Token Prefix
}

// ApplicationUserCreateIn ApplicationUserCreateRequestBody
type ApplicationUserCreateIn struct {
	IsSuperAdmin *bool  `json:"is_super_admin,omitempty"` // Alters super admin state of the organization application user
	Name         string `json:"name"`
}

// ApplicationUserCreateOut ApplicationUserCreateResponse
type ApplicationUserCreateOut struct {
	IsSuperAdmin bool   `json:"is_super_admin"` // Super admin state of the organization application user
	Name         string `json:"name"`
	UserEmail    string `json:"user_email"` // User Email
	UserId       string `json:"user_id"`    // User ID
}

// ApplicationUserGetOut ApplicationUserGetResponse
type ApplicationUserGetOut struct {
	IsSuperAdmin bool   `json:"is_super_admin"` // Super admin state of the organization application user
	Name         string `json:"name"`
	UserEmail    string `json:"user_email"` // User Email
	UserId       string `json:"user_id"`    // User ID
}
type ApplicationUserOut struct {
	IsSuperAdmin bool   `json:"is_super_admin"` // Super admin state of the organization application user
	Name         string `json:"name"`
	UserEmail    string `json:"user_email"` // User Email
	UserId       string `json:"user_id"`    // User ID
}

// ApplicationUserUpdateIn ApplicationUserUpdateRequestBody
type ApplicationUserUpdateIn struct {
	IsSuperAdmin *bool  `json:"is_super_admin,omitempty"` // Alters super admin state of the organization application user
	Name         string `json:"name"`
}

// ApplicationUserUpdateOut ApplicationUserUpdateResponse
type ApplicationUserUpdateOut struct {
	IsSuperAdmin bool   `json:"is_super_admin"` // Super admin state of the organization application user
	Name         string `json:"name"`
	UserEmail    string `json:"user_email"` // User Email
	UserId       string `json:"user_id"`    // User ID
}
type TokenOut struct {
	CreateTime                 time.Time  `json:"create_time"`      // Create Time
	CreatedManually            bool       `json:"created_manually"` // True for tokens explicitly created via the access_tokens API, false for tokens created via login.
	CurrentlyActive            bool       `json:"currently_active"` // true if API request was made with this access token
	Description                *string    `json:"description,omitempty"`
	ExpiryTime                 *time.Time `json:"expiry_time,omitempty"`                    // Timestamp when the access token will expire unless extended, if ever
	ExtendWhenUsed             *bool      `json:"extend_when_used,omitempty"`               // Extend token expiration time when token is used. Only applicable if max_age_seconds is specified.
	LastIp                     *string    `json:"last_ip,omitempty"`                        // IP address the access token was last used from in case it has ever been used
	LastUsedTime               *time.Time `json:"last_used_time,omitempty"`                 // Timestamp when the access token was last used, if ever
	LastUserAgent              *string    `json:"last_user_agent,omitempty"`                // User agent string of the client that last used the token in case it has ever been used
	LastUserAgentHumanReadable *string    `json:"last_user_agent_human_readable,omitempty"` // Human readable user agent string of the client that last used the token in case user agent is known
	MaxAgeSeconds              *int       `json:"max_age_seconds,omitempty"`                // Time the token remains valid since creation (or since last use if extend_when_used is true)
	Scopes                     []string   `json:"scopes,omitempty"`                         // Scopes this token is restricted to if specified
	TokenPrefix                string     `json:"token_prefix"`                             // First characters of the actual token value. Full value is only exposed after creation. This value is used when updating or revoking tokens. Note that the value may contain /, + and = characters and must be URL encoded when used (/ =&gt; %2F, + =&gt; %2B, = =&gt; %3D).
}

// applicationUserAccessTokensListOut ApplicationUserAccessTokensListResponse
type applicationUserAccessTokensListOut struct {
	Tokens []TokenOut `json:"tokens"` // Tokens
}

// applicationUsersListOut ApplicationUsersListResponse
type applicationUsersListOut struct {
	ApplicationUsers []ApplicationUserOut `json:"application_users"` // Application Users
}
