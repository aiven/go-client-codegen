// Code generated by Aiven. DO NOT EDIT.

package kafka

import (
	"context"
	"encoding/json"
	"fmt"
	"net/url"
)

type Handler interface {
	// ServiceKafkaAclAdd add a Kafka ACL entry
	// POST /v1/project/{project}/service/{service_name}/acl
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceKafkaAclAdd
	ServiceKafkaAclAdd(ctx context.Context, project string, serviceName string, in *ServiceKafkaAclAddIn) ([]AclOut, error)

	// ServiceKafkaAclDelete delete a Kafka ACL entry
	// DELETE /v1/project/{project}/service/{service_name}/acl/{kafka_acl_id}
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceKafkaAclDelete
	ServiceKafkaAclDelete(ctx context.Context, project string, serviceName string, kafkaAclId string) ([]AclOut, error)

	// ServiceKafkaAclList list Kafka ACL entries
	// GET /v1/project/{project}/service/{service_name}/acl
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceKafkaAclList
	ServiceKafkaAclList(ctx context.Context, project string, serviceName string) ([]AclOut, error)

	// ServiceKafkaQuotaCreate create Kafka quota
	// POST /v1/project/{project}/service/{service_name}/quota
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceKafkaQuotaCreate
	ServiceKafkaQuotaCreate(ctx context.Context, project string, serviceName string, in *ServiceKafkaQuotaCreateIn) error

	// ServiceKafkaQuotaDelete delete Kafka quota
	// DELETE /v1/project/{project}/service/{service_name}/quota
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceKafkaQuotaDelete
	ServiceKafkaQuotaDelete(ctx context.Context, project string, serviceName string) error

	// ServiceKafkaQuotaDescribe describe Specific Kafka quotas
	// GET /v1/project/{project}/service/{service_name}/quota/describe
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceKafkaQuotaDescribe
	ServiceKafkaQuotaDescribe(ctx context.Context, project string, serviceName string) (*ServiceKafkaQuotaDescribeOut, error)

	// ServiceKafkaQuotaList list Kafka quotas
	// GET /v1/project/{project}/service/{service_name}/quota
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceKafkaQuotaList
	ServiceKafkaQuotaList(ctx context.Context, project string, serviceName string) ([]QuotaOut, error)

	// ServiceKafkaTieredStorageStorageUsageByTopic get the Kafka tiered storage object storage usage by topic
	// GET /v1/project/{project}/service/{service_name}/kafka/tiered-storage/storage-usage/by-topic
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceKafkaTieredStorageStorageUsageByTopic
	ServiceKafkaTieredStorageStorageUsageByTopic(ctx context.Context, project string, serviceName string) (map[string]any, error)

	// ServiceKafkaTieredStorageStorageUsageTotal get the Kafka tiered storage total object storage usage
	// GET /v1/project/{project}/service/{service_name}/kafka/tiered-storage/storage-usage/total
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceKafkaTieredStorageStorageUsageTotal
	ServiceKafkaTieredStorageStorageUsageTotal(ctx context.Context, project string, serviceName string) (int, error)

	// ServiceKafkaTieredStorageSummary get the Kafka tiered storage summary
	// GET /v1/project/{project}/service/{service_name}/kafka/tiered-storage/summary
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceKafkaTieredStorageSummary
	ServiceKafkaTieredStorageSummary(ctx context.Context, project string, serviceName string) (*ServiceKafkaTieredStorageSummaryOut, error)
}

// doer http client
type doer interface {
	Do(ctx context.Context, operationID, method, path string, in any, query ...[2]string) ([]byte, error)
}

func NewHandler(doer doer) KafkaHandler {
	return KafkaHandler{doer}
}

type KafkaHandler struct {
	doer doer
}

func (h *KafkaHandler) ServiceKafkaAclAdd(ctx context.Context, project string, serviceName string, in *ServiceKafkaAclAddIn) ([]AclOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/acl", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceKafkaAclAdd", "POST", path, in)
	if err != nil {
		return nil, err
	}
	out := new(serviceKafkaAclAddOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Acl, nil
}
func (h *KafkaHandler) ServiceKafkaAclDelete(ctx context.Context, project string, serviceName string, kafkaAclId string) ([]AclOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/acl/%s", url.PathEscape(project), url.PathEscape(serviceName), url.PathEscape(kafkaAclId))
	b, err := h.doer.Do(ctx, "ServiceKafkaAclDelete", "DELETE", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(serviceKafkaAclDeleteOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Acl, nil
}
func (h *KafkaHandler) ServiceKafkaAclList(ctx context.Context, project string, serviceName string) ([]AclOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/acl", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceKafkaAclList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(serviceKafkaAclListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Acl, nil
}
func (h *KafkaHandler) ServiceKafkaQuotaCreate(ctx context.Context, project string, serviceName string, in *ServiceKafkaQuotaCreateIn) error {
	path := fmt.Sprintf("/v1/project/%s/service/%s/quota", url.PathEscape(project), url.PathEscape(serviceName))
	_, err := h.doer.Do(ctx, "ServiceKafkaQuotaCreate", "POST", path, in)
	return err
}
func (h *KafkaHandler) ServiceKafkaQuotaDelete(ctx context.Context, project string, serviceName string) error {
	path := fmt.Sprintf("/v1/project/%s/service/%s/quota", url.PathEscape(project), url.PathEscape(serviceName))
	_, err := h.doer.Do(ctx, "ServiceKafkaQuotaDelete", "DELETE", path, nil)
	return err
}
func (h *KafkaHandler) ServiceKafkaQuotaDescribe(ctx context.Context, project string, serviceName string) (*ServiceKafkaQuotaDescribeOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/quota/describe", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceKafkaQuotaDescribe", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(serviceKafkaQuotaDescribeOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.Quota, nil
}
func (h *KafkaHandler) ServiceKafkaQuotaList(ctx context.Context, project string, serviceName string) ([]QuotaOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/quota", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceKafkaQuotaList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(serviceKafkaQuotaListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Quotas, nil
}
func (h *KafkaHandler) ServiceKafkaTieredStorageStorageUsageByTopic(ctx context.Context, project string, serviceName string) (map[string]any, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/kafka/tiered-storage/storage-usage/by-topic", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceKafkaTieredStorageStorageUsageByTopic", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(serviceKafkaTieredStorageUsageByTopicOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.StorageUsage, nil
}
func (h *KafkaHandler) ServiceKafkaTieredStorageStorageUsageTotal(ctx context.Context, project string, serviceName string) (int, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/kafka/tiered-storage/storage-usage/total", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceKafkaTieredStorageStorageUsageTotal", "GET", path, nil)
	if err != nil {
		return 0, err
	}
	out := new(serviceKafkaTieredStorageUsageTotalOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return 0, err
	}
	return out.TotalStorageUsage, nil
}
func (h *KafkaHandler) ServiceKafkaTieredStorageSummary(ctx context.Context, project string, serviceName string) (*ServiceKafkaTieredStorageSummaryOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/kafka/tiered-storage/summary", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceKafkaTieredStorageSummary", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(ServiceKafkaTieredStorageSummaryOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type AclOut struct {
	Id         *string        `json:"id,omitempty"` // ID
	Permission PermissionType `json:"permission"`   // Kafka permission
	Topic      string         `json:"topic"`        // Topic name pattern
	Username   string         `json:"username"`
}
type HourlyOut struct {
	EstimatedCost   *string `json:"estimated_cost,omitempty"` // The estimated cost in USD of tiered storage for this hour
	HourStart       string  `json:"hour_start"`               // Timestamp in ISO 8601 format, always in UTC
	PeakStoredBytes int     `json:"peak_stored_bytes"`        // Peak bytes stored on object storage at this hour
}
type PermissionType string

const (
	PermissionTypeAdmin     PermissionType = "admin"
	PermissionTypeRead      PermissionType = "read"
	PermissionTypeReadwrite PermissionType = "readwrite"
	PermissionTypeWrite     PermissionType = "write"
)

func PermissionTypeChoices() []string {
	return []string{"admin", "read", "readwrite", "write"}
}

type QuotaOut struct {
	ClientId          *string `json:"client-id,omitempty"` // client-id
	ConsumerByteRate  float64 `json:"consumer_byte_rate"`  // consumer network throttle
	ProducerByteRate  float64 `json:"producer_byte_rate"`  // producer network throttle
	RequestPercentage float64 `json:"request_percentage"`  // cpu percentage throttle
	User              string  `json:"user"`                // user
}

// ServiceKafkaAclAddIn ServiceKafkaAclAddRequestBody
type ServiceKafkaAclAddIn struct {
	Permission PermissionType `json:"permission"` // Kafka permission
	Topic      string         `json:"topic"`      // Topic name pattern
	Username   string         `json:"username"`
}

// ServiceKafkaQuotaCreateIn ServiceKafkaQuotaCreateRequestBody
type ServiceKafkaQuotaCreateIn struct {
	ClientId          *string  `json:"client-id,omitempty"`          // client-id
	ConsumerByteRate  *float64 `json:"consumer_byte_rate,omitempty"` // consumer network throttle
	ProducerByteRate  *float64 `json:"producer_byte_rate,omitempty"` // producer network throttle
	RequestPercentage *float64 `json:"request_percentage,omitempty"` // cpu percentage throttle
	User              *string  `json:"user,omitempty"`               // user
}

// ServiceKafkaQuotaDescribeOut kafka quota
type ServiceKafkaQuotaDescribeOut struct {
	ClientId          *string `json:"client-id,omitempty"` // client-id
	ConsumerByteRate  float64 `json:"consumer_byte_rate"`  // consumer network throttle
	ProducerByteRate  float64 `json:"producer_byte_rate"`  // producer network throttle
	RequestPercentage float64 `json:"request_percentage"`  // cpu percentage throttle
	User              string  `json:"user"`                // user
}

// ServiceKafkaTieredStorageSummaryOut ServiceKafkaTieredStorageSummaryResponse
type ServiceKafkaTieredStorageSummaryOut struct {
	CurrentCost         string                 `json:"current_cost"`              // The current cost in USD of tiered storage since the beginning of the billing period
	ForecastedCost      string                 `json:"forecasted_cost"`           // The forecasted cost in USD of tiered storage in the billing period
	ForecastedRate      *string                `json:"forecasted_rate,omitempty"` // The rate on GBs/hour used to calculate the forecasted cost
	StorageUsageHistory StorageUsageHistoryOut `json:"storage_usage_history"`     // History of usage and cumulative costs in the billing period
	TotalStorageUsage   int                    `json:"total_storage_usage"`       // Total storage usage by tiered storage, in bytes
}

// StorageUsageHistoryOut History of usage and cumulative costs in the billing period
type StorageUsageHistoryOut struct {
	Hourly []HourlyOut `json:"hourly"` // History by hour
}

// serviceKafkaAclAddOut ServiceKafkaAclAddResponse
type serviceKafkaAclAddOut struct {
	Acl []AclOut `json:"acl"` // List of Kafka ACL entries
}

// serviceKafkaAclDeleteOut ServiceKafkaAclDeleteResponse
type serviceKafkaAclDeleteOut struct {
	Acl []AclOut `json:"acl"` // List of Kafka ACL entries
}

// serviceKafkaAclListOut ServiceKafkaAclListResponse
type serviceKafkaAclListOut struct {
	Acl []AclOut `json:"acl"` // List of Kafka ACL entries
}

// serviceKafkaQuotaDescribeOut ServiceKafkaQuotaDescribeResponse
type serviceKafkaQuotaDescribeOut struct {
	Quota ServiceKafkaQuotaDescribeOut `json:"quota"` // kafka quota
}

// serviceKafkaQuotaListOut ServiceKafkaQuotaListResponse
type serviceKafkaQuotaListOut struct {
	Quotas []QuotaOut `json:"quotas"` // List of kafka quotas
}

// serviceKafkaTieredStorageUsageByTopicOut ServiceKafkaTieredStorageStorageUsageByTopicResponse
type serviceKafkaTieredStorageUsageByTopicOut struct {
	StorageUsage map[string]any `json:"storage_usage"` // Storage usage by tiered storage by topics
}

// serviceKafkaTieredStorageUsageTotalOut ServiceKafkaTieredStorageStorageUsageTotalResponse
type serviceKafkaTieredStorageUsageTotalOut struct {
	TotalStorageUsage int `json:"total_storage_usage"` // Total storage usage by tiered storage, in bytes
}
