// Code generated by Aiven. DO NOT EDIT.

package project

import (
	"context"
	"encoding/json"
	"fmt"
	"net/url"
	"time"
)

type Handler interface {
	// ListProjectVpcPeeringConnectionTypes list VPC peering connection types for a project
	// GET /v1/project/{project}/vpc-peering-connection-types
	// https://api.aiven.io/doc/#tag/Project/operation/ListProjectVpcPeeringConnectionTypes
	ListProjectVpcPeeringConnectionTypes(ctx context.Context, project string) ([]VpcPeeringConnectionTypeOut, error)

	// ProjectAlertsList list active alerts for a project
	// GET /v1/project/{project}/alerts
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectAlertsList
	ProjectAlertsList(ctx context.Context, project string) ([]AlertOut, error)

	// ProjectCreate create a project
	// POST /v1/project
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectCreate
	ProjectCreate(ctx context.Context, in *ProjectCreateIn) (*ProjectCreateOut, error)

	// ProjectDelete delete project
	// DELETE /v1/project/{project}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectDelete
	ProjectDelete(ctx context.Context, project string) error

	// ProjectGenerateSbomDownloadUrl generate SBOM for project
	// GET /v1/project/{project}/generate-sbom-download-url/{file_format}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectGenerateSbomDownloadUrl
	ProjectGenerateSbomDownloadUrl(ctx context.Context, project string, fileFormat string) (string, error)

	// ProjectGet get project details
	// GET /v1/project/{project}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectGet
	ProjectGet(ctx context.Context, project string) (*ProjectGetOut, error)

	// ProjectGetEventLogs get project event log entries
	// GET /v1/project/{project}/events
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectGetEventLogs
	ProjectGetEventLogs(ctx context.Context, project string) ([]EventOut, error)

	// ProjectInvite send project membership invitation
	// POST /v1/project/{project}/invite
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectInvite
	ProjectInvite(ctx context.Context, project string, in *ProjectInviteIn) error

	// ProjectInviteAccept confirm project invite
	// POST /v1/project/{project}/invite/{invite_verification_code}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectInviteAccept
	ProjectInviteAccept(ctx context.Context, project string, inviteVerificationCode string) (*ProjectInviteAcceptOut, error)

	// ProjectInviteDelete delete an invitation to a project
	// DELETE /v1/project/{project}/invite/{invited_email}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectInviteDelete
	ProjectInviteDelete(ctx context.Context, project string, invitedEmail string) error

	// ProjectKmsGetCA retrieve project CA certificate
	// GET /v1/project/{project}/kms/ca
	// https://api.aiven.io/doc/#tag/Project_Key_Management/operation/ProjectKmsGetCA
	ProjectKmsGetCA(ctx context.Context, project string) (string, error)

	// ProjectList list projects
	// GET /v1/project
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectList
	ProjectList(ctx context.Context) (*ProjectListOut, error)

	// ProjectPrivatelinkAvailabilityList list Privatelink cloud availability and prices for a project
	// GET /v1/project/{project}/privatelink-availability
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectPrivatelinkAvailabilityList
	ProjectPrivatelinkAvailabilityList(ctx context.Context, project string) ([]PrivatelinkAvailabilityOut, error)

	// ProjectServicePlanList list service plans
	// GET /v1/project/{project}/service-types/{service_type}/plans
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectServicePlanList
	ProjectServicePlanList(ctx context.Context, project string, serviceType string) ([]ServicePlanOut, error)

	// ProjectServicePlanPriceGet get plan pricing
	// GET /v1/project/{project}/pricing/service-types/{service_type}/plans/{service_plan}/clouds/{cloud}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectServicePlanPriceGet
	ProjectServicePlanPriceGet(ctx context.Context, project string, serviceType string, servicePlan string, cloud string) (*ProjectServicePlanPriceGetOut, error)

	// ProjectServicePlanSpecsGet get service plan details
	// GET /v1/project/{project}/service-types/{service_type}/plans/{service_plan}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectServicePlanSpecsGet
	ProjectServicePlanSpecsGet(ctx context.Context, project string, serviceType string, servicePlan string) (*ProjectServicePlanSpecsGetOut, error)

	// ProjectServiceTypesGet get service type details
	// GET /v1/project/{project}/service-types/{service_type}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectServiceTypesGet
	ProjectServiceTypesGet(ctx context.Context, project string, serviceType string) (*ProjectServiceTypesGetOut, error)

	// ProjectServiceTypesList list service types
	// GET /v1/project/{project}/service-types
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectServiceTypesList
	ProjectServiceTypesList(ctx context.Context, project string) (*ProjectServiceTypesListOut, error)

	// ProjectTagsList list all tags attached to this project
	// GET /v1/project/{project}/tags
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectTagsList
	ProjectTagsList(ctx context.Context, project string) (map[string]string, error)

	// ProjectTagsReplace replace all project tags with a new set of tags, deleting old ones
	// PUT /v1/project/{project}/tags
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectTagsReplace
	ProjectTagsReplace(ctx context.Context, project string, in *ProjectTagsReplaceIn) error

	// ProjectTagsUpdate update one or more tags, creating ones that don't exist, and deleting ones given NULL value
	// PATCH /v1/project/{project}/tags
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectTagsUpdate
	ProjectTagsUpdate(ctx context.Context, project string, in *ProjectTagsUpdateIn) error

	// ProjectUpdate update project
	// PUT /v1/project/{project}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectUpdate
	ProjectUpdate(ctx context.Context, project string, in *ProjectUpdateIn) (*ProjectUpdateOut, error)

	// ProjectUserList list users with access to the project. May contain same user multiple times if they belong to multiple teams associated to the project
	// GET /v1/project/{project}/users
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectUserList
	ProjectUserList(ctx context.Context, project string) (*ProjectUserListOut, error)

	// ProjectUserRemove remove user from the project
	// DELETE /v1/project/{project}/user/{user_email}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectUserRemove
	ProjectUserRemove(ctx context.Context, project string, userEmail string) error

	// ProjectUserUpdate update a project user
	// PUT /v1/project/{project}/user/{user_email}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectUserUpdate
	ProjectUserUpdate(ctx context.Context, project string, userEmail string, in *ProjectUserUpdateIn) error
}

// doer http client
type doer interface {
	Do(ctx context.Context, operationID, method, path string, in any, query ...[2]string) ([]byte, error)
}

func NewHandler(doer doer) ProjectHandler {
	return ProjectHandler{doer}
}

type ProjectHandler struct {
	doer doer
}

func (h *ProjectHandler) ListProjectVpcPeeringConnectionTypes(ctx context.Context, project string) ([]VpcPeeringConnectionTypeOut, error) {
	path := fmt.Sprintf("/v1/project/%s/vpc-peering-connection-types", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ListProjectVpcPeeringConnectionTypes", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(listProjectVpcPeeringConnectionTypesOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.VpcPeeringConnectionTypes, nil
}
func (h *ProjectHandler) ProjectAlertsList(ctx context.Context, project string) ([]AlertOut, error) {
	path := fmt.Sprintf("/v1/project/%s/alerts", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ProjectAlertsList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(projectAlertsListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Alerts, nil
}
func (h *ProjectHandler) ProjectCreate(ctx context.Context, in *ProjectCreateIn) (*ProjectCreateOut, error) {
	path := fmt.Sprintf("/v1/project")
	b, err := h.doer.Do(ctx, "ProjectCreate", "POST", path, in)
	if err != nil {
		return nil, err
	}
	out := new(projectCreateOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.Project, nil
}
func (h *ProjectHandler) ProjectDelete(ctx context.Context, project string) error {
	path := fmt.Sprintf("/v1/project/%s", url.PathEscape(project))
	_, err := h.doer.Do(ctx, "ProjectDelete", "DELETE", path, nil)
	return err
}
func (h *ProjectHandler) ProjectGenerateSbomDownloadUrl(ctx context.Context, project string, fileFormat string) (string, error) {
	path := fmt.Sprintf("/v1/project/%s/generate-sbom-download-url/%s", url.PathEscape(project), url.PathEscape(fileFormat))
	b, err := h.doer.Do(ctx, "ProjectGenerateSbomDownloadUrl", "GET", path, nil)
	if err != nil {
		return "", err
	}
	out := new(projectGenerateSbomDownloadUrlOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return "", err
	}
	return out.DownloadUrl, nil
}
func (h *ProjectHandler) ProjectGet(ctx context.Context, project string) (*ProjectGetOut, error) {
	path := fmt.Sprintf("/v1/project/%s", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ProjectGet", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(projectGetOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.Project, nil
}
func (h *ProjectHandler) ProjectGetEventLogs(ctx context.Context, project string) ([]EventOut, error) {
	path := fmt.Sprintf("/v1/project/%s/events", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ProjectGetEventLogs", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(projectGetEventLogsOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Events, nil
}
func (h *ProjectHandler) ProjectInvite(ctx context.Context, project string, in *ProjectInviteIn) error {
	path := fmt.Sprintf("/v1/project/%s/invite", url.PathEscape(project))
	_, err := h.doer.Do(ctx, "ProjectInvite", "POST", path, in)
	return err
}
func (h *ProjectHandler) ProjectInviteAccept(ctx context.Context, project string, inviteVerificationCode string) (*ProjectInviteAcceptOut, error) {
	path := fmt.Sprintf("/v1/project/%s/invite/%s", url.PathEscape(project), url.PathEscape(inviteVerificationCode))
	b, err := h.doer.Do(ctx, "ProjectInviteAccept", "POST", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(projectInviteAcceptOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.InviteDetails, nil
}
func (h *ProjectHandler) ProjectInviteDelete(ctx context.Context, project string, invitedEmail string) error {
	path := fmt.Sprintf("/v1/project/%s/invite/%s", url.PathEscape(project), url.PathEscape(invitedEmail))
	_, err := h.doer.Do(ctx, "ProjectInviteDelete", "DELETE", path, nil)
	return err
}
func (h *ProjectHandler) ProjectKmsGetCA(ctx context.Context, project string) (string, error) {
	path := fmt.Sprintf("/v1/project/%s/kms/ca", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ProjectKmsGetCA", "GET", path, nil)
	if err != nil {
		return "", err
	}
	out := new(projectKmsGetCaOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return "", err
	}
	return out.Certificate, nil
}
func (h *ProjectHandler) ProjectList(ctx context.Context) (*ProjectListOut, error) {
	path := fmt.Sprintf("/v1/project")
	b, err := h.doer.Do(ctx, "ProjectList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(ProjectListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *ProjectHandler) ProjectPrivatelinkAvailabilityList(ctx context.Context, project string) ([]PrivatelinkAvailabilityOut, error) {
	path := fmt.Sprintf("/v1/project/%s/privatelink-availability", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ProjectPrivatelinkAvailabilityList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(projectPrivatelinkAvailabilityListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.PrivatelinkAvailability, nil
}
func (h *ProjectHandler) ProjectServicePlanList(ctx context.Context, project string, serviceType string) ([]ServicePlanOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service-types/%s/plans", url.PathEscape(project), url.PathEscape(serviceType))
	b, err := h.doer.Do(ctx, "ProjectServicePlanList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(projectServicePlanListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.ServicePlans, nil
}
func (h *ProjectHandler) ProjectServicePlanPriceGet(ctx context.Context, project string, serviceType string, servicePlan string, cloud string) (*ProjectServicePlanPriceGetOut, error) {
	path := fmt.Sprintf("/v1/project/%s/pricing/service-types/%s/plans/%s/clouds/%s", url.PathEscape(project), url.PathEscape(serviceType), url.PathEscape(servicePlan), url.PathEscape(cloud))
	b, err := h.doer.Do(ctx, "ProjectServicePlanPriceGet", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(ProjectServicePlanPriceGetOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *ProjectHandler) ProjectServicePlanSpecsGet(ctx context.Context, project string, serviceType string, servicePlan string) (*ProjectServicePlanSpecsGetOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service-types/%s/plans/%s", url.PathEscape(project), url.PathEscape(serviceType), url.PathEscape(servicePlan))
	b, err := h.doer.Do(ctx, "ProjectServicePlanSpecsGet", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(ProjectServicePlanSpecsGetOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *ProjectHandler) ProjectServiceTypesGet(ctx context.Context, project string, serviceType string) (*ProjectServiceTypesGetOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service-types/%s", url.PathEscape(project), url.PathEscape(serviceType))
	b, err := h.doer.Do(ctx, "ProjectServiceTypesGet", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(ProjectServiceTypesGetOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *ProjectHandler) ProjectServiceTypesList(ctx context.Context, project string) (*ProjectServiceTypesListOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service-types", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ProjectServiceTypesList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(ProjectServiceTypesListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *ProjectHandler) ProjectTagsList(ctx context.Context, project string) (map[string]string, error) {
	path := fmt.Sprintf("/v1/project/%s/tags", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ProjectTagsList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(projectTagsListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Tags, nil
}
func (h *ProjectHandler) ProjectTagsReplace(ctx context.Context, project string, in *ProjectTagsReplaceIn) error {
	path := fmt.Sprintf("/v1/project/%s/tags", url.PathEscape(project))
	_, err := h.doer.Do(ctx, "ProjectTagsReplace", "PUT", path, in)
	return err
}
func (h *ProjectHandler) ProjectTagsUpdate(ctx context.Context, project string, in *ProjectTagsUpdateIn) error {
	path := fmt.Sprintf("/v1/project/%s/tags", url.PathEscape(project))
	_, err := h.doer.Do(ctx, "ProjectTagsUpdate", "PATCH", path, in)
	return err
}
func (h *ProjectHandler) ProjectUpdate(ctx context.Context, project string, in *ProjectUpdateIn) (*ProjectUpdateOut, error) {
	path := fmt.Sprintf("/v1/project/%s", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ProjectUpdate", "PUT", path, in)
	if err != nil {
		return nil, err
	}
	out := new(projectUpdateOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.Project, nil
}
func (h *ProjectHandler) ProjectUserList(ctx context.Context, project string) (*ProjectUserListOut, error) {
	path := fmt.Sprintf("/v1/project/%s/users", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ProjectUserList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(ProjectUserListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *ProjectHandler) ProjectUserRemove(ctx context.Context, project string, userEmail string) error {
	path := fmt.Sprintf("/v1/project/%s/user/%s", url.PathEscape(project), url.PathEscape(userEmail))
	_, err := h.doer.Do(ctx, "ProjectUserRemove", "DELETE", path, nil)
	return err
}
func (h *ProjectHandler) ProjectUserUpdate(ctx context.Context, project string, userEmail string, in *ProjectUserUpdateIn) error {
	path := fmt.Sprintf("/v1/project/%s/user/%s", url.PathEscape(project), url.PathEscape(userEmail))
	_, err := h.doer.Do(ctx, "ProjectUserUpdate", "PUT", path, in)
	return err
}

// AggregatorOut Service type information
type AggregatorOut struct {
	DefaultVersion         *string        `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string         `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string        `json:"latest_available_version,omitempty"` // Latest available version of the service
	UserConfigSchema       map[string]any `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}
type AlertOut struct {
	CreateTime  time.Time `json:"create_time"`            // Event creation timestamp (ISO 8601)
	Event       string    `json:"event"`                  // Name of the alerting event
	NodeName    *string   `json:"node_name,omitempty"`    // Name of the service node
	ProjectName string    `json:"project_name"`           // Project name
	ServiceName *string   `json:"service_name,omitempty"` // Service name
	ServiceType *string   `json:"service_type,omitempty"` // Service type code
	Severity    string    `json:"severity"`               // Severity of the event
}
type AnyType string

const (
	AnyTypeAdmin                  AnyType = "admin"
	AnyTypeDeveloper              AnyType = "developer"
	AnyTypeOperator               AnyType = "operator"
	AnyTypeProjectreadPermissions AnyType = "project:read_permissions"
	AnyTypeReadOnly               AnyType = "read_only"
)

func AnyTypeChoices() []string {
	return []string{"admin", "developer", "operator", "project:read_permissions", "read_only"}
}

// BackupConfigOut Backup configuration for this service plan
type BackupConfigOut struct {
	FrequentIntervalMinutes    *int             `json:"frequent_interval_minutes,omitempty"`     // Interval of taking a frequent backup in service types supporting different backup schedules
	FrequentOldestAgeMinutes   *int             `json:"frequent_oldest_age_minutes,omitempty"`   // Maximum age of the oldest frequent backup in service types supporting different backup schedules
	InfrequentIntervalMinutes  *int             `json:"infrequent_interval_minutes,omitempty"`   // Interval of taking an infrequent backup in service types supporting different backup schedules
	InfrequentOldestAgeMinutes *int             `json:"infrequent_oldest_age_minutes,omitempty"` // Maximum age of the oldest infrequent backup in service types supporting different backup schedules
	Interval                   int              `json:"interval"`                                // The interval, in hours, at which backups are generated. For some services, like PostgreSQL, this is the interval at which full snapshots are taken and continuous incremental backup stream is maintained in addition to that.
	MaxCount                   int              `json:"max_count"`                               // Maximum number of backups to keep. Zero when no backups are created.
	RecoveryMode               RecoveryModeType `json:"recovery_mode"`                           // Mechanism how backups can be restored. 'basic' means a backup is restored as is so that the system is restored to the state it was when the backup was generated. 'pitr' means point-in-time-recovery, which allows restoring the system to any state since the first available full snapshot.
}
type BillingCurrencyType string

const (
	BillingCurrencyTypeAud BillingCurrencyType = "AUD"
	BillingCurrencyTypeCad BillingCurrencyType = "CAD"
	BillingCurrencyTypeChf BillingCurrencyType = "CHF"
	BillingCurrencyTypeDkk BillingCurrencyType = "DKK"
	BillingCurrencyTypeEur BillingCurrencyType = "EUR"
	BillingCurrencyTypeGbp BillingCurrencyType = "GBP"
	BillingCurrencyTypeJpy BillingCurrencyType = "JPY"
	BillingCurrencyTypeNok BillingCurrencyType = "NOK"
	BillingCurrencyTypeNzd BillingCurrencyType = "NZD"
	BillingCurrencyTypeSek BillingCurrencyType = "SEK"
	BillingCurrencyTypeSgd BillingCurrencyType = "SGD"
	BillingCurrencyTypeUsd BillingCurrencyType = "USD"
)

func BillingCurrencyTypeChoices() []string {
	return []string{"AUD", "CAD", "CHF", "DKK", "EUR", "GBP", "JPY", "NOK", "NZD", "SEK", "SGD", "USD"}
}

type BillingEmailIn struct {
	Email string `json:"email"` // User email address
}
type BillingEmailOut struct {
	Email string `json:"email"` // User email address
}

// CardInfoOut Credit card assigned to the project
type CardInfoOut struct {
	Brand       string `json:"brand"`
	CardId      string `json:"card_id"` // Credit card ID
	Country     string `json:"country"`
	CountryCode string `json:"country_code"` // Two letter ISO country code
	ExpMonth    int    `json:"exp_month"`    // Expiration month
	ExpYear     int    `json:"exp_year"`     // Expiration year
	Last4       string `json:"last4"`        // Credit card last four digits
	Name        string `json:"name"`         // Name on the credit card
	UserEmail   string `json:"user_email"`   // User email address
}

// CassandraOut Service type information
type CassandraOut struct {
	DefaultVersion         *string        `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string         `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string        `json:"latest_available_version,omitempty"` // Latest available version of the service
	UserConfigSchema       map[string]any `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}

// ClickhouseOut Service type information
type ClickhouseOut struct {
	DefaultVersion         *string        `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string         `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string        `json:"latest_available_version,omitempty"` // Latest available version of the service
	UserConfigSchema       map[string]any `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}

// DbOut Service type information
type DbOut struct {
	DefaultVersion         *string        `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string         `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string        `json:"latest_available_version,omitempty"` // Latest available version of the service
	UserConfigSchema       map[string]any `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}

// DragonflyOut Service type information
type DragonflyOut struct {
	DefaultVersion         *string        `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string         `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string        `json:"latest_available_version,omitempty"` // Latest available version of the service
	UserConfigSchema       map[string]any `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}

// ElasticsearchOut Service EOL extension
type ElasticsearchOut struct {
	EolDate string `json:"eol_date"` // Extended EOL date
	Version string `json:"version"`  // Service version
}

// ElasticsearchOutAlt Service type information
type ElasticsearchOutAlt struct {
	DefaultVersion         *string        `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string         `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string        `json:"latest_available_version,omitempty"` // Latest available version of the service
	UserConfigSchema       map[string]any `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}

// EndOfLifeExtensionOut End of life extension information
type EndOfLifeExtensionOut struct {
	Elasticsearch *ElasticsearchOut `json:"elasticsearch,omitempty"` // Service EOL extension
}
type EventOut struct {
	Actor       string `json:"actor"`        // Initiator of the event
	EventDesc   string `json:"event_desc"`   // Event description
	EventType   string `json:"event_type"`   // Event type identifier
	Id          string `json:"id"`           // Event identifier (unique across all projects)
	ServiceName string `json:"service_name"` // Service name
	Time        string `json:"time"`         // Timestamp in ISO 8601 format, always in UTC
}

// FlinkOut Service type information
type FlinkOut struct {
	DefaultVersion         *string        `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string         `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string        `json:"latest_available_version,omitempty"` // Latest available version of the service
	UserConfigSchema       map[string]any `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}

// GrafanaOut Service type information
type GrafanaOut struct {
	DefaultVersion         *string        `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string         `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string        `json:"latest_available_version,omitempty"` // Latest available version of the service
	UserConfigSchema       map[string]any `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}
type GroupUserOut struct {
	MemberType  MemberType `json:"member_type"`   // Project member type
	RealName    string     `json:"real_name"`     // User real name
	UserEmail   string     `json:"user_email"`    // User email address
	UserGroupId string     `json:"user_group_id"` // User group ID
}

// InfluxdbOut Service type information
type InfluxdbOut struct {
	DefaultVersion         *string        `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string         `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string        `json:"latest_available_version,omitempty"` // Latest available version of the service
	UserConfigSchema       map[string]any `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}
type InvitationOut struct {
	InviteTime        time.Time  `json:"invite_time"`         // Timestamp in ISO 8601 format, always in UTC
	InvitedUserEmail  string     `json:"invited_user_email"`  // User email address
	InvitingUserEmail string     `json:"inviting_user_email"` // User email address
	MemberType        MemberType `json:"member_type"`         // Project member type
}

// KafkaConnectOut Service type information
type KafkaConnectOut struct {
	DefaultVersion         *string        `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string         `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string        `json:"latest_available_version,omitempty"` // Latest available version of the service
	UserConfigSchema       map[string]any `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}

// KafkaMirrormakerOut Service type information
type KafkaMirrormakerOut struct {
	DefaultVersion         *string        `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string         `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string        `json:"latest_available_version,omitempty"` // Latest available version of the service
	UserConfigSchema       map[string]any `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}

// KafkaOut Service type information
type KafkaOut struct {
	DefaultVersion         *string        `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string         `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string        `json:"latest_available_version,omitempty"` // Latest available version of the service
	UserConfigSchema       map[string]any `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}
type MemberType string

const (
	MemberTypeAdmin                  MemberType = "admin"
	MemberTypeDeveloper              MemberType = "developer"
	MemberTypeOperator               MemberType = "operator"
	MemberTypeProjectreadPermissions MemberType = "project:read_permissions"
	MemberTypeReadOnly               MemberType = "read_only"
)

func MemberTypeChoices() []string {
	return []string{"admin", "developer", "operator", "project:read_permissions", "read_only"}
}

// MysqlOut Service type information
type MysqlOut struct {
	DefaultVersion         *string        `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string         `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string        `json:"latest_available_version,omitempty"` // Latest available version of the service
	UserConfigSchema       map[string]any `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}

// OpensearchOut Service type information
type OpensearchOut struct {
	DefaultVersion         *string        `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string         `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string        `json:"latest_available_version,omitempty"` // Latest available version of the service
	UserConfigSchema       map[string]any `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}

// PgOut Service type information
type PgOut struct {
	DefaultVersion         *string        `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string         `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string        `json:"latest_available_version,omitempty"` // Latest available version of the service
	UserConfigSchema       map[string]any `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}
type PrivatelinkAvailabilityOut struct {
	CloudName string `json:"cloud_name"` // Target cloud
	PriceUsd  string `json:"price_usd"`  // Hourly privatelink price in this cloud region
}

// ProjectCreateIn ProjectCreateRequestBody
type ProjectCreateIn struct {
	AccountId                    *string             `json:"account_id,omitempty"`                       // Account ID
	AddAccountOwnersAdminAccess  *bool               `json:"add_account_owners_admin_access,omitempty"`  // [DEPRECATED] If account_id is set, grant account owner team admin access to the new project. This flag is ignored, and assumed true.
	AddressLines                 *[]string           `json:"address_lines,omitempty"`                    // [DEPRECATED] Address lines
	BasePort                     *int                `json:"base_port,omitempty"`                        // Base value that new services in this project will use to derive their port numbers.
	BillingAddress               *string             `json:"billing_address,omitempty"`                  // DEPRECATED: use split address fields like company, address_lines, zip_code, city and state instead
	BillingCurrency              BillingCurrencyType `json:"billing_currency,omitempty"`                 // [DEPRECATED] Billing currency
	BillingEmails                *[]BillingEmailIn   `json:"billing_emails,omitempty"`                   // [DEPRECATED] Billing emails
	BillingExtraText             *string             `json:"billing_extra_text,omitempty"`               // [DEPRECATED] Extra text to be included in all project invoices
	BillingGroupId               *string             `json:"billing_group_id,omitempty"`                 // Billing group ID
	CardId                       *string             `json:"card_id,omitempty"`                          // [DEPRECATED] Credit card ID
	City                         *string             `json:"city,omitempty"`                             // [DEPRECATED] Address city
	Cloud                        *string             `json:"cloud,omitempty"`                            // Target cloud
	Company                      *string             `json:"company,omitempty"`                          // Name of a company
	CopyFromProject              *string             `json:"copy_from_project,omitempty"`                // Project name from which to copy settings to the new project
	CopyTags                     *bool               `json:"copy_tags,omitempty"`                        // Copy tags from the source project. If request contains additional tags, the tags copied from source are updated with them.
	CountryCode                  *string             `json:"country_code,omitempty"`                     // [DEPRECATED] Two letter country code for billing country
	Project                      string              `json:"project"`                                    // Project name
	State                        *string             `json:"state,omitempty"`                            // [DEPRECATED] Address state
	Tags                         *map[string]string  `json:"tags,omitempty"`                             // Set of resource tags
	TechEmails                   *[]TechEmailIn      `json:"tech_emails,omitempty"`                      // List of project tech email addresses
	UseSourceProjectBillingGroup *bool               `json:"use_source_project_billing_group,omitempty"` // Use the same billing group that is used in source project.
	VatId                        *string             `json:"vat_id,omitempty"`                           // [DEPRECATED] EU VAT identification
	ZipCode                      *string             `json:"zip_code,omitempty"`                         // [DEPRECATED] Address zip code
}

// ProjectCreateOut Project information
type ProjectCreateOut struct {
	AccountId             string                 `json:"account_id"`                        // Account ID
	AccountName           *string                `json:"account_name,omitempty"`            // Account name
	AddressLines          []string               `json:"address_lines,omitempty"`           // Address lines
	AvailableCredits      *string                `json:"available_credits,omitempty"`       // Available credits, in USD
	BillingAddress        string                 `json:"billing_address"`                   // DEPRECATED: use split address fields like company, address_lines, zip_code, city and state instead
	BillingCurrency       BillingCurrencyType    `json:"billing_currency,omitempty"`        // Billing currency
	BillingEmails         []BillingEmailOut      `json:"billing_emails"`                    // List of project billing email addresses
	BillingExtraText      *string                `json:"billing_extra_text,omitempty"`      // Extra text to be included in all project invoices, e.g. purchase order or cost center number
	BillingGroupId        string                 `json:"billing_group_id"`                  // Billing group ID
	BillingGroupName      string                 `json:"billing_group_name"`                // Billing group name
	CardInfo              *CardInfoOut           `json:"card_info,omitempty"`               // Credit card assigned to the project
	City                  *string                `json:"city,omitempty"`                    // Address city
	Company               *string                `json:"company,omitempty"`                 // Name of a company
	Country               string                 `json:"country"`                           // Billing country
	CountryCode           string                 `json:"country_code"`                      // Two letter ISO country code
	DefaultCloud          string                 `json:"default_cloud"`                     // Default cloud to use when launching services
	EndOfLifeExtension    *EndOfLifeExtensionOut `json:"end_of_life_extension,omitempty"`   // End of life extension information
	EstimatedBalance      string                 `json:"estimated_balance"`                 // Estimated balance, in USD
	EstimatedBalanceLocal *string                `json:"estimated_balance_local,omitempty"` // Estimated balance, in billing currency
	Features              map[string]any         `json:"features,omitempty"`                // Feature flags
	OrganizationId        string                 `json:"organization_id"`                   // Organization ID
	PaymentMethod         string                 `json:"payment_method"`                    // Payment method
	ProjectName           string                 `json:"project_name"`                      // Project name
	State                 *string                `json:"state,omitempty"`                   // Address state
	Tags                  map[string]string      `json:"tags,omitempty"`                    // Set of resource tags
	TechEmails            []TechEmailOut         `json:"tech_emails,omitempty"`             // List of project tech email addresses
	TenantId              *string                `json:"tenant_id,omitempty"`               // Tenant ID
	TrialExpirationTime   *time.Time             `json:"trial_expiration_time,omitempty"`   // Trial expiration time (ISO 8601)
	VatId                 string                 `json:"vat_id"`                            // EU VAT Identification Number
	ZipCode               *string                `json:"zip_code,omitempty"`                // Address zip code
}

// ProjectGetOut Project information
type ProjectGetOut struct {
	AccountId             string                 `json:"account_id"`                        // Account ID
	AccountName           *string                `json:"account_name,omitempty"`            // Account name
	AddressLines          []string               `json:"address_lines,omitempty"`           // Address lines
	AvailableCredits      *string                `json:"available_credits,omitempty"`       // Available credits, in USD
	BillingAddress        string                 `json:"billing_address"`                   // DEPRECATED: use split address fields like company, address_lines, zip_code, city and state instead
	BillingCurrency       BillingCurrencyType    `json:"billing_currency,omitempty"`        // Billing currency
	BillingEmails         []BillingEmailOut      `json:"billing_emails"`                    // List of project billing email addresses
	BillingExtraText      *string                `json:"billing_extra_text,omitempty"`      // Extra text to be included in all project invoices, e.g. purchase order or cost center number
	BillingGroupId        string                 `json:"billing_group_id"`                  // Billing group ID
	BillingGroupName      string                 `json:"billing_group_name"`                // Billing group name
	CardInfo              *CardInfoOut           `json:"card_info,omitempty"`               // Credit card assigned to the project
	City                  *string                `json:"city,omitempty"`                    // Address city
	Company               *string                `json:"company,omitempty"`                 // Name of a company
	Country               string                 `json:"country"`                           // Billing country
	CountryCode           string                 `json:"country_code"`                      // Two letter ISO country code
	DefaultCloud          string                 `json:"default_cloud"`                     // Default cloud to use when launching services
	EndOfLifeExtension    *EndOfLifeExtensionOut `json:"end_of_life_extension,omitempty"`   // End of life extension information
	EstimatedBalance      string                 `json:"estimated_balance"`                 // Estimated balance, in USD
	EstimatedBalanceLocal *string                `json:"estimated_balance_local,omitempty"` // Estimated balance, in billing currency
	Features              map[string]any         `json:"features,omitempty"`                // Feature flags
	OrganizationId        string                 `json:"organization_id"`                   // Organization ID
	PaymentMethod         string                 `json:"payment_method"`                    // Payment method
	ProjectName           string                 `json:"project_name"`                      // Project name
	State                 *string                `json:"state,omitempty"`                   // Address state
	Tags                  map[string]string      `json:"tags,omitempty"`                    // Set of resource tags
	TechEmails            []TechEmailOut         `json:"tech_emails,omitempty"`             // List of project tech email addresses
	TenantId              *string                `json:"tenant_id,omitempty"`               // Tenant ID
	TrialExpirationTime   *time.Time             `json:"trial_expiration_time,omitempty"`   // Trial expiration time (ISO 8601)
	VatId                 string                 `json:"vat_id"`                            // EU VAT Identification Number
	ZipCode               *string                `json:"zip_code,omitempty"`                // Address zip code
}

// ProjectInviteAcceptOut Details of verified invite
type ProjectInviteAcceptOut struct {
	UserEmail string `json:"user_email"` // User email address
}

// ProjectInviteIn ProjectInviteRequestBody
type ProjectInviteIn struct {
	MemberType MemberType `json:"member_type,omitempty"` // Project member type
	UserEmail  string     `json:"user_email"`            // User email address
}

// ProjectListOut ProjectListResponse
type ProjectListOut struct {
	ProjectMembership  ProjectMembershipOut   `json:"project_membership"`            // Project membership and type of membership
	ProjectMemberships *ProjectMembershipsOut `json:"project_memberships,omitempty"` // List of project membership and type of membership
	Projects           []ProjectOut           `json:"projects"`                      // List of projects
}

// ProjectMembershipOut Project membership and type of membership
type ProjectMembershipOut struct {
	Any AnyType `json:"ANY,omitempty"` // Project member type
}

// ProjectMembershipsOut List of project membership and type of membership
type ProjectMembershipsOut struct {
	Any []string `json:"ANY,omitempty"` // List of project member type
}
type ProjectOut struct {
	AccountId             string                 `json:"account_id"`                        // Account ID
	AccountName           *string                `json:"account_name,omitempty"`            // Account name
	AddressLines          []string               `json:"address_lines,omitempty"`           // Address lines
	AvailableCredits      *string                `json:"available_credits,omitempty"`       // Available credits, in USD
	BillingAddress        string                 `json:"billing_address"`                   // DEPRECATED: use split address fields like company, address_lines, zip_code, city and state instead
	BillingCurrency       BillingCurrencyType    `json:"billing_currency,omitempty"`        // Billing currency
	BillingEmails         []BillingEmailOut      `json:"billing_emails"`                    // List of project billing email addresses
	BillingExtraText      *string                `json:"billing_extra_text,omitempty"`      // Extra text to be included in all project invoices, e.g. purchase order or cost center number
	BillingGroupId        string                 `json:"billing_group_id"`                  // Billing group ID
	BillingGroupName      string                 `json:"billing_group_name"`                // Billing group name
	CardInfo              *CardInfoOut           `json:"card_info,omitempty"`               // Credit card assigned to the project
	City                  *string                `json:"city,omitempty"`                    // Address city
	Company               *string                `json:"company,omitempty"`                 // Name of a company
	Country               string                 `json:"country"`                           // Billing country
	CountryCode           string                 `json:"country_code"`                      // Two letter ISO country code
	DefaultCloud          string                 `json:"default_cloud"`                     // Default cloud to use when launching services
	EndOfLifeExtension    *EndOfLifeExtensionOut `json:"end_of_life_extension,omitempty"`   // End of life extension information
	EstimatedBalance      string                 `json:"estimated_balance"`                 // Estimated balance, in USD
	EstimatedBalanceLocal *string                `json:"estimated_balance_local,omitempty"` // Estimated balance, in billing currency
	Features              map[string]any         `json:"features,omitempty"`                // Feature flags
	OrganizationId        string                 `json:"organization_id"`                   // Organization ID
	PaymentMethod         string                 `json:"payment_method"`                    // Payment method
	ProjectName           string                 `json:"project_name"`                      // Project name
	State                 *string                `json:"state,omitempty"`                   // Address state
	Tags                  map[string]string      `json:"tags,omitempty"`                    // Set of resource tags
	TechEmails            []TechEmailOut         `json:"tech_emails,omitempty"`             // List of project tech email addresses
	TenantId              *string                `json:"tenant_id,omitempty"`               // Tenant ID
	TrialExpirationTime   *time.Time             `json:"trial_expiration_time,omitempty"`   // Trial expiration time (ISO 8601)
	VatId                 string                 `json:"vat_id"`                            // EU VAT Identification Number
	ZipCode               *string                `json:"zip_code,omitempty"`                // Address zip code
}

// ProjectServicePlanPriceGetOut ProjectServicePlanPriceGetResponse
type ProjectServicePlanPriceGetOut struct {
	BasePriceUsd            string  `json:"base_price_usd"`                        // Hourly service price in this region
	CloudName               string  `json:"cloud_name"`                            // Target cloud
	ExtraDiskPricePerGbUsd  *string `json:"extra_disk_price_per_gb_usd,omitempty"` // Hourly additional disk space price per GiB in this region
	ObjectStorageGbPriceUsd *string `json:"object_storage_gb_price_usd,omitempty"` // Hourly additional disk space price per GiB in this region
	ServicePlan             string  `json:"service_plan"`                          // Subscription plan
	ServiceType             string  `json:"service_type"`                          // Service type code
}

// ProjectServicePlanSpecsGetOut ProjectServicePlanSpecsGetResponse
type ProjectServicePlanSpecsGetOut struct {
	BackupConfig     BackupConfigOut `json:"backup_config"`                // Backup configuration for this service plan
	DiskSpaceCapMb   *int            `json:"disk_space_cap_mb,omitempty"`  // Maximum amount of disk space possible for the plan in the given region
	DiskSpaceMb      int             `json:"disk_space_mb"`                // Combined amount of service disk space of all service nodes in megabytes
	DiskSpaceStepMb  *int            `json:"disk_space_step_mb,omitempty"` // Disk space change step size
	MaxMemoryPercent *int            `json:"max_memory_percent,omitempty"` // Maximum amount of system memory as a percentage (0-100) the service can actually use after taking into account management overhead. This is relevant for memory bound services for which some service management operations require allocating proportional amount of memory on top the basic load.
	NodeCount        int             `json:"node_count"`                   // Number of nodes in this service plan
	ServicePlan      string          `json:"service_plan"`                 // Subscription plan
	ServiceType      string          `json:"service_type"`                 // Service type code
	ShardCount       *int            `json:"shard_count,omitempty"`        // Number of shards in this service plan
}

// ProjectServiceTypesGetOut ProjectServiceTypesGetResponse
type ProjectServiceTypesGetOut struct {
	DefaultVersion         *string        `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string         `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string        `json:"latest_available_version,omitempty"` // Latest available version of the service
	UserConfigSchema       map[string]any `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}

// ProjectServiceTypesListOut ProjectServiceTypesListResponse
type ProjectServiceTypesListOut struct {
	Cassandra        *CassandraOut        `json:"cassandra,omitempty"`         // Service type information
	Clickhouse       *ClickhouseOut       `json:"clickhouse,omitempty"`        // Service type information
	Dragonfly        *DragonflyOut        `json:"dragonfly,omitempty"`         // Service type information
	Elasticsearch    *ElasticsearchOutAlt `json:"elasticsearch,omitempty"`     // Service type information
	Flink            *FlinkOut            `json:"flink,omitempty"`             // Service type information
	Grafana          *GrafanaOut          `json:"grafana,omitempty"`           // Service type information
	Influxdb         *InfluxdbOut         `json:"influxdb,omitempty"`          // Service type information
	Kafka            *KafkaOut            `json:"kafka,omitempty"`             // Service type information
	KafkaConnect     *KafkaConnectOut     `json:"kafka_connect,omitempty"`     // Service type information
	KafkaMirrormaker *KafkaMirrormakerOut `json:"kafka_mirrormaker,omitempty"` // Service type information
	M3Aggregator     *AggregatorOut       `json:"m3aggregator,omitempty"`      // Service type information
	M3Db             *DbOut               `json:"m3db,omitempty"`              // Service type information
	Mysql            *MysqlOut            `json:"mysql,omitempty"`             // Service type information
	Opensearch       *OpensearchOut       `json:"opensearch,omitempty"`        // Service type information
	Pg               *PgOut               `json:"pg,omitempty"`                // Service type information
	Redis            *RedisOut            `json:"redis,omitempty"`             // Service type information
	Valkey           *ValkeyOut           `json:"valkey,omitempty"`            // Service type information
}

// ProjectTagsReplaceIn ProjectTagsReplaceRequestBody
type ProjectTagsReplaceIn struct {
	Tags map[string]string `json:"tags"` // Set of resource tags
}

// ProjectTagsUpdateIn ProjectTagsUpdateRequestBody
type ProjectTagsUpdateIn struct {
	Tags map[string]string `json:"tags"` // Set of resource tags
}

// ProjectUpdateIn ProjectUpdateRequestBody
type ProjectUpdateIn struct {
	AccountId                   *string             `json:"account_id,omitempty"`                      // Account ID
	AddAccountOwnersAdminAccess *bool               `json:"add_account_owners_admin_access,omitempty"` // [DEPRECATED] If account_id is set, grant account owner team admin access to this project. This flag is ignored and assumed true.
	AddressLines                *[]string           `json:"address_lines,omitempty"`                   // [DEPRECATED] Address lines
	BillingAddress              *string             `json:"billing_address,omitempty"`                 // DEPRECATED: use split address fields like company, address_lines, zip_code, city and state instead
	BillingCurrency             BillingCurrencyType `json:"billing_currency,omitempty"`                // [DEPRECATED] Billing currency
	BillingEmails               *[]BillingEmailIn   `json:"billing_emails,omitempty"`                  // [DEPRECATED] List of project billing email addresses
	BillingExtraText            *string             `json:"billing_extra_text,omitempty"`              // [DEPRECATED] Extra text to be included in all project invoices, e.g. purchase order or cost center number
	BillingGroupId              *string             `json:"billing_group_id,omitempty"`                // Billing group ID
	CardId                      *string             `json:"card_id,omitempty"`                         // [DEPRECATED] Credit card ID
	City                        *string             `json:"city,omitempty"`                            // [DEPRECATED] Address city
	Cloud                       *string             `json:"cloud,omitempty"`                           // Target cloud
	Company                     *string             `json:"company,omitempty"`                         // Name of a company
	CountryCode                 *string             `json:"country_code,omitempty"`                    // [DEPRECATED] Two letter country code for billing country
	ProjectName                 *string             `json:"project_name,omitempty"`                    // Project name
	State                       *string             `json:"state,omitempty"`                           // [DEPRECATED] Address state
	Tags                        *map[string]string  `json:"tags,omitempty"`                            // Set of resource tags
	TechEmails                  *[]TechEmailIn      `json:"tech_emails,omitempty"`                     // List of project tech email addresses
	VatId                       *string             `json:"vat_id,omitempty"`                          // [DEPRECATED] EU VAT Identification Number
	ZipCode                     *string             `json:"zip_code,omitempty"`                        // [DEPRECATED] Address zip code
}

// ProjectUpdateOut Project information
type ProjectUpdateOut struct {
	AccountId             string                 `json:"account_id"`                        // Account ID
	AccountName           *string                `json:"account_name,omitempty"`            // Account name
	AddressLines          []string               `json:"address_lines,omitempty"`           // Address lines
	AvailableCredits      *string                `json:"available_credits,omitempty"`       // Available credits, in USD
	BillingAddress        string                 `json:"billing_address"`                   // DEPRECATED: use split address fields like company, address_lines, zip_code, city and state instead
	BillingCurrency       BillingCurrencyType    `json:"billing_currency,omitempty"`        // Billing currency
	BillingEmails         []BillingEmailOut      `json:"billing_emails"`                    // List of project billing email addresses
	BillingExtraText      *string                `json:"billing_extra_text,omitempty"`      // Extra text to be included in all project invoices, e.g. purchase order or cost center number
	BillingGroupId        string                 `json:"billing_group_id"`                  // Billing group ID
	BillingGroupName      string                 `json:"billing_group_name"`                // Billing group name
	CardInfo              *CardInfoOut           `json:"card_info,omitempty"`               // Credit card assigned to the project
	City                  *string                `json:"city,omitempty"`                    // Address city
	Company               *string                `json:"company,omitempty"`                 // Name of a company
	Country               string                 `json:"country"`                           // Billing country
	CountryCode           string                 `json:"country_code"`                      // Two letter ISO country code
	DefaultCloud          string                 `json:"default_cloud"`                     // Default cloud to use when launching services
	EndOfLifeExtension    *EndOfLifeExtensionOut `json:"end_of_life_extension,omitempty"`   // End of life extension information
	EstimatedBalance      string                 `json:"estimated_balance"`                 // Estimated balance, in USD
	EstimatedBalanceLocal *string                `json:"estimated_balance_local,omitempty"` // Estimated balance, in billing currency
	Features              map[string]any         `json:"features,omitempty"`                // Feature flags
	OrganizationId        string                 `json:"organization_id"`                   // Organization ID
	PaymentMethod         string                 `json:"payment_method"`                    // Payment method
	ProjectName           string                 `json:"project_name"`                      // Project name
	State                 *string                `json:"state,omitempty"`                   // Address state
	Tags                  map[string]string      `json:"tags,omitempty"`                    // Set of resource tags
	TechEmails            []TechEmailOut         `json:"tech_emails,omitempty"`             // List of project tech email addresses
	TenantId              *string                `json:"tenant_id,omitempty"`               // Tenant ID
	TrialExpirationTime   *time.Time             `json:"trial_expiration_time,omitempty"`   // Trial expiration time (ISO 8601)
	VatId                 string                 `json:"vat_id"`                            // EU VAT Identification Number
	ZipCode               *string                `json:"zip_code,omitempty"`                // Address zip code
}

// ProjectUserListOut ProjectUserListResponse
type ProjectUserListOut struct {
	GroupUsers  []GroupUserOut  `json:"group_users"` // List of users in groups that have access to the project
	Invitations []InvitationOut `json:"invitations"` // List of pending invitations
	Users       []UserOut       `json:"users"`       // List of project's users
}

// ProjectUserUpdateIn ProjectUserUpdateRequestBody
type ProjectUserUpdateIn struct {
	MemberType MemberType `json:"member_type"` // Project member type
}
type RecoveryModeType string

const (
	RecoveryModeTypeBasic RecoveryModeType = "basic"
	RecoveryModeTypePitr  RecoveryModeType = "pitr"
)

func RecoveryModeTypeChoices() []string {
	return []string{"basic", "pitr"}
}

// RedisOut Service type information
type RedisOut struct {
	DefaultVersion         *string        `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string         `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string        `json:"latest_available_version,omitempty"` // Latest available version of the service
	UserConfigSchema       map[string]any `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}
type ServicePlanOut struct {
	BackupConfig     BackupConfigOut `json:"backup_config"`                // Backup configuration for this service plan
	MaxMemoryPercent *int            `json:"max_memory_percent,omitempty"` // Maximum amount of system memory as a percentage (0-100) the service can actually use after taking into account management overhead. This is relevant for memory bound services for which some service management operations require allocating proportional amount of memory on top the basic load.
	NodeCount        *int            `json:"node_count,omitempty"`         // Number of nodes in this service plan
	Regions          map[string]any  `json:"regions,omitempty"`            // Service plan hourly price per cloud region
	ServicePlan      string          `json:"service_plan"`                 // Subscription plan
	ServiceType      string          `json:"service_type"`                 // Service type code
	ShardCount       *int            `json:"shard_count,omitempty"`        // Number of shards in this service plan
}
type TechEmailIn struct {
	Email string `json:"email"` // User email address
}
type TechEmailOut struct {
	Email string `json:"email"` // User email address
}
type UserOut struct {
	Auth           []string   `json:"auth"`                // List of user's required authentication methods
	BillingContact bool       `json:"billing_contact"`     // Set for project's billing contacts
	CreateTime     time.Time  `json:"create_time"`         // Timestamp in ISO 8601 format, always in UTC
	MemberType     MemberType `json:"member_type"`         // Project member type
	RealName       *string    `json:"real_name,omitempty"` // User real name
	TeamId         string     `json:"team_id"`             // Team ID
	TeamName       string     `json:"team_name"`           // Team name
	UserEmail      string     `json:"user_email"`          // User email address
	UserId         string     `json:"user_id"`             // User ID
}

// ValkeyOut Service type information
type ValkeyOut struct {
	DefaultVersion         *string        `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string         `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string        `json:"latest_available_version,omitempty"` // Latest available version of the service
	UserConfigSchema       map[string]any `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}
type VpcPeeringConnectionType string

const (
	VpcPeeringConnectionTypeAwsTgwVpcAttachment     VpcPeeringConnectionType = "aws-tgw-vpc-attachment"
	VpcPeeringConnectionTypeAwsVpcPeeringConnection VpcPeeringConnectionType = "aws-vpc-peering-connection"
	VpcPeeringConnectionTypeAzureVnetPeering        VpcPeeringConnectionType = "azure-vnet-peering"
	VpcPeeringConnectionTypeGoogleVpcPeering        VpcPeeringConnectionType = "google-vpc-peering"
	VpcPeeringConnectionTypeUpcloudVpcPeering       VpcPeeringConnectionType = "upcloud-vpc-peering"
)

func VpcPeeringConnectionTypeChoices() []string {
	return []string{"aws-tgw-vpc-attachment", "aws-vpc-peering-connection", "azure-vnet-peering", "google-vpc-peering", "upcloud-vpc-peering"}
}

type VpcPeeringConnectionTypeOut struct {
	CloudName                string                   `json:"cloud_name"`                  // Target cloud
	PriceUsd                 string                   `json:"price_usd"`                   // Hourly peering connection price in this cloud region
	VpcPeeringConnectionType VpcPeeringConnectionType `json:"vpc_peering_connection_type"` // Type of network connection from the VPC
}

// listProjectVpcPeeringConnectionTypesOut ListProjectVpcPeeringConnectionTypesResponse
type listProjectVpcPeeringConnectionTypesOut struct {
	VpcPeeringConnectionTypes []VpcPeeringConnectionTypeOut `json:"vpc_peering_connection_types"` // Supported VPC peering connection types with pricing information for supported clouds
}

// projectAlertsListOut ProjectAlertsListResponse
type projectAlertsListOut struct {
	Alerts []AlertOut `json:"alerts"` // List of active alerts for the service
}

// projectCreateOut ProjectCreateResponse
type projectCreateOut struct {
	Project ProjectCreateOut `json:"project"` // Project information
}

// projectGenerateSbomDownloadUrlOut ProjectGenerateSbomDownloadUrlResponse
type projectGenerateSbomDownloadUrlOut struct {
	DownloadUrl string `json:"download_url"` // Relative signed URL for report download
}

// projectGetEventLogsOut ProjectGetEventLogsResponse
type projectGetEventLogsOut struct {
	Events []EventOut `json:"events"` // List of project event log entries
}

// projectGetOut ProjectGetResponse
type projectGetOut struct {
	Project ProjectGetOut `json:"project"` // Project information
}

// projectInviteAcceptOut ProjectInviteAcceptResponse
type projectInviteAcceptOut struct {
	InviteDetails ProjectInviteAcceptOut `json:"invite_details"` // Details of verified invite
}

// projectKmsGetCaOut ProjectKmsGetCAResponse
type projectKmsGetCaOut struct {
	Certificate string `json:"certificate"` // PEM encoded certificate
}

// projectPrivatelinkAvailabilityListOut ProjectPrivatelinkAvailabilityListResponse
type projectPrivatelinkAvailabilityListOut struct {
	PrivatelinkAvailability []PrivatelinkAvailabilityOut `json:"privatelink_availability"` // Privatelink pricing information for supported clouds
}

// projectServicePlanListOut ProjectServicePlanListResponse
type projectServicePlanListOut struct {
	ServicePlans []ServicePlanOut `json:"service_plans"` // List of plans available for this type of service
}

// projectTagsListOut ProjectTagsListResponse
type projectTagsListOut struct {
	Tags map[string]string `json:"tags,omitempty"` // Set of resource tags
}

// projectUpdateOut ProjectUpdateResponse
type projectUpdateOut struct {
	Project ProjectUpdateOut `json:"project"` // Project information
}
