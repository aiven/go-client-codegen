// Code generated by Aiven. DO NOT EDIT.

package project

import (
	"context"
	"encoding/json"
	"fmt"
	"time"
)

type Handler interface {
	// ListProjectVpcPeeringConnectionTypes list VPC peering connection types for a project
	// GET /project/{project}/vpc-peering-connection-types
	// https://api.aiven.io/doc/#tag/Project/operation/ListProjectVpcPeeringConnectionTypes
	ListProjectVpcPeeringConnectionTypes(ctx context.Context, project string) ([]VpcPeeringConnectionType, error)

	// ProjectAlertsList list active alerts for a project
	// GET /project/{project}/alerts
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectAlertsList
	ProjectAlertsList(ctx context.Context, project string) ([]Alert, error)

	// ProjectCreate create a project
	// POST /project
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectCreate
	ProjectCreate(ctx context.Context, in *ProjectCreateIn) (*Project, error)

	// ProjectDelete delete project
	// DELETE /project/{project}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectDelete
	ProjectDelete(ctx context.Context, project string) error

	// ProjectGenerateSbomDownloadUrl generate SBOM for project
	// GET /project/{project}/generate-sbom-download-url/{file_format}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectGenerateSbomDownloadUrl
	ProjectGenerateSbomDownloadUrl(ctx context.Context, project string, fileFormat string) (string, error)

	// ProjectGet get project details
	// GET /project/{project}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectGet
	ProjectGet(ctx context.Context, project string) (*Project, error)

	// ProjectGetEventLogs get project event log entries
	// GET /project/{project}/events
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectGetEventLogs
	ProjectGetEventLogs(ctx context.Context, project string) ([]Event, error)

	// ProjectInvite send project membership invitation
	// POST /project/{project}/invite
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectInvite
	ProjectInvite(ctx context.Context, project string, in *ProjectInviteIn) error

	// ProjectInviteAccept confirm project invite
	// POST /project/{project}/invite/{invite_verification_code}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectInviteAccept
	ProjectInviteAccept(ctx context.Context, project string, inviteVerificationCode string) (*InviteDetails, error)

	// ProjectInviteDelete delete an invitation to a project
	// DELETE /project/{project}/invite/{invited_email}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectInviteDelete
	ProjectInviteDelete(ctx context.Context, project string, invitedEmail string) error

	// ProjectList list projects
	// GET /project
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectList
	ProjectList(ctx context.Context) (*ProjectListOut, error)

	// ProjectPrivatelinkAvailabilityList list Privatelink cloud availability and prices for a project
	// GET /project/{project}/privatelink-availability
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectPrivatelinkAvailabilityList
	ProjectPrivatelinkAvailabilityList(ctx context.Context, project string) ([]PrivatelinkAvailability, error)

	// ProjectTagsList list all tags attached to this project
	// GET /project/{project}/tags
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectTagsList
	ProjectTagsList(ctx context.Context, project string) (map[string]string, error)

	// ProjectTagsReplace replace all project tags with a new set of tags, deleting old ones
	// PUT /project/{project}/tags
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectTagsReplace
	ProjectTagsReplace(ctx context.Context, project string, in *ProjectTagsReplaceIn) error

	// ProjectTagsUpdate update one or more tags, creating ones that don't exist, and deleting ones given NULL value
	// PATCH /project/{project}/tags
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectTagsUpdate
	ProjectTagsUpdate(ctx context.Context, project string, in *ProjectTagsUpdateIn) error

	// ProjectUpdate update project
	// PUT /project/{project}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectUpdate
	ProjectUpdate(ctx context.Context, project string, in *ProjectUpdateIn) (*Project, error)

	// ProjectUserList list users with access to the project. May contain same user multiple times if they belong to multiple teams associated to the project
	// GET /project/{project}/users
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectUserList
	ProjectUserList(ctx context.Context, project string) (*ProjectUserListOut, error)

	// ProjectUserRemove remove user from the project
	// DELETE /project/{project}/user/{user_email}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectUserRemove
	ProjectUserRemove(ctx context.Context, project string, userEmail string) error

	// ProjectUserUpdate update a project user
	// PUT /project/{project}/user/{user_email}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectUserUpdate
	ProjectUserUpdate(ctx context.Context, project string, userEmail string, in *ProjectUserUpdateIn) error
}

func NewHandler(doer doer) ProjectHandler {
	return ProjectHandler{doer}
}

type doer interface {
	Do(ctx context.Context, operationID, method, path string, v any) ([]byte, error)
}

type ProjectHandler struct {
	doer doer
}

func (h *ProjectHandler) ListProjectVpcPeeringConnectionTypes(ctx context.Context, project string) ([]VpcPeeringConnectionType, error) {
	path := fmt.Sprintf("/project/%s/vpc-peering-connection-types", project)
	b, err := h.doer.Do(ctx, "ListProjectVpcPeeringConnectionTypes", "GET", path, nil)
	out := new(listProjectVpcPeeringConnectionTypesOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.VpcPeeringConnectionTypes, nil
}
func (h *ProjectHandler) ProjectAlertsList(ctx context.Context, project string) ([]Alert, error) {
	path := fmt.Sprintf("/project/%s/alerts", project)
	b, err := h.doer.Do(ctx, "ProjectAlertsList", "GET", path, nil)
	out := new(projectAlertsListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Alerts, nil
}
func (h *ProjectHandler) ProjectCreate(ctx context.Context, in *ProjectCreateIn) (*Project, error) {
	path := fmt.Sprintf("/project")
	b, err := h.doer.Do(ctx, "ProjectCreate", "POST", path, in)
	out := new(projectCreateOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Project, nil
}
func (h *ProjectHandler) ProjectDelete(ctx context.Context, project string) error {
	path := fmt.Sprintf("/project/%s", project)
	_, err := h.doer.Do(ctx, "ProjectDelete", "DELETE", path, nil)
	return err
}
func (h *ProjectHandler) ProjectGenerateSbomDownloadUrl(ctx context.Context, project string, fileFormat string) (string, error) {
	path := fmt.Sprintf("/project/%s/generate-sbom-download-url/%s", project, fileFormat)
	b, err := h.doer.Do(ctx, "ProjectGenerateSbomDownloadUrl", "GET", path, nil)
	out := new(projectGenerateSbomDownloadUrlOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return "", err
	}
	return out.DownloadUrl, nil
}
func (h *ProjectHandler) ProjectGet(ctx context.Context, project string) (*Project, error) {
	path := fmt.Sprintf("/project/%s", project)
	b, err := h.doer.Do(ctx, "ProjectGet", "GET", path, nil)
	out := new(projectGetOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Project, nil
}
func (h *ProjectHandler) ProjectGetEventLogs(ctx context.Context, project string) ([]Event, error) {
	path := fmt.Sprintf("/project/%s/events", project)
	b, err := h.doer.Do(ctx, "ProjectGetEventLogs", "GET", path, nil)
	out := new(projectGetEventLogsOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Events, nil
}
func (h *ProjectHandler) ProjectInvite(ctx context.Context, project string, in *ProjectInviteIn) error {
	path := fmt.Sprintf("/project/%s/invite", project)
	_, err := h.doer.Do(ctx, "ProjectInvite", "POST", path, in)
	return err
}
func (h *ProjectHandler) ProjectInviteAccept(ctx context.Context, project string, inviteVerificationCode string) (*InviteDetails, error) {
	path := fmt.Sprintf("/project/%s/invite/%s", project, inviteVerificationCode)
	b, err := h.doer.Do(ctx, "ProjectInviteAccept", "POST", path, nil)
	out := new(projectInviteAcceptOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.InviteDetails, nil
}
func (h *ProjectHandler) ProjectInviteDelete(ctx context.Context, project string, invitedEmail string) error {
	path := fmt.Sprintf("/project/%s/invite/%s", project, invitedEmail)
	_, err := h.doer.Do(ctx, "ProjectInviteDelete", "DELETE", path, nil)
	return err
}
func (h *ProjectHandler) ProjectList(ctx context.Context) (*ProjectListOut, error) {
	path := fmt.Sprintf("/project")
	b, err := h.doer.Do(ctx, "ProjectList", "GET", path, nil)
	out := new(ProjectListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *ProjectHandler) ProjectPrivatelinkAvailabilityList(ctx context.Context, project string) ([]PrivatelinkAvailability, error) {
	path := fmt.Sprintf("/project/%s/privatelink-availability", project)
	b, err := h.doer.Do(ctx, "ProjectPrivatelinkAvailabilityList", "GET", path, nil)
	out := new(projectPrivatelinkAvailabilityListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.PrivatelinkAvailability, nil
}
func (h *ProjectHandler) ProjectTagsList(ctx context.Context, project string) (map[string]string, error) {
	path := fmt.Sprintf("/project/%s/tags", project)
	b, err := h.doer.Do(ctx, "ProjectTagsList", "GET", path, nil)
	out := new(projectTagsListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Tags, nil
}
func (h *ProjectHandler) ProjectTagsReplace(ctx context.Context, project string, in *ProjectTagsReplaceIn) error {
	path := fmt.Sprintf("/project/%s/tags", project)
	_, err := h.doer.Do(ctx, "ProjectTagsReplace", "PUT", path, in)
	return err
}
func (h *ProjectHandler) ProjectTagsUpdate(ctx context.Context, project string, in *ProjectTagsUpdateIn) error {
	path := fmt.Sprintf("/project/%s/tags", project)
	_, err := h.doer.Do(ctx, "ProjectTagsUpdate", "PATCH", path, in)
	return err
}
func (h *ProjectHandler) ProjectUpdate(ctx context.Context, project string, in *ProjectUpdateIn) (*Project, error) {
	path := fmt.Sprintf("/project/%s", project)
	b, err := h.doer.Do(ctx, "ProjectUpdate", "PUT", path, in)
	out := new(projectUpdateOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Project, nil
}
func (h *ProjectHandler) ProjectUserList(ctx context.Context, project string) (*ProjectUserListOut, error) {
	path := fmt.Sprintf("/project/%s/users", project)
	b, err := h.doer.Do(ctx, "ProjectUserList", "GET", path, nil)
	out := new(ProjectUserListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *ProjectHandler) ProjectUserRemove(ctx context.Context, project string, userEmail string) error {
	path := fmt.Sprintf("/project/%s/user/%s", project, userEmail)
	_, err := h.doer.Do(ctx, "ProjectUserRemove", "DELETE", path, nil)
	return err
}
func (h *ProjectHandler) ProjectUserUpdate(ctx context.Context, project string, userEmail string, in *ProjectUserUpdateIn) error {
	path := fmt.Sprintf("/project/%s/user/%s", project, userEmail)
	_, err := h.doer.Do(ctx, "ProjectUserUpdate", "PUT", path, in)
	return err
}

type Alert struct {
	CreateTime  time.Time `json:"create_time"`
	Event       string    `json:"event"`
	NodeName    string    `json:"node_name,omitempty"`
	ProjectName string    `json:"project_name"`
	ServiceName string    `json:"service_name,omitempty"`
	ServiceType string    `json:"service_type,omitempty"`
	Severity    string    `json:"severity"`
}
type BillingCurrencyType string

const (
	BillingCurrencyTypeAud BillingCurrencyType = "AUD"
	BillingCurrencyTypeCad BillingCurrencyType = "CAD"
	BillingCurrencyTypeChf BillingCurrencyType = "CHF"
	BillingCurrencyTypeDkk BillingCurrencyType = "DKK"
	BillingCurrencyTypeEur BillingCurrencyType = "EUR"
	BillingCurrencyTypeGbp BillingCurrencyType = "GBP"
	BillingCurrencyTypeJpy BillingCurrencyType = "JPY"
	BillingCurrencyTypeNok BillingCurrencyType = "NOK"
	BillingCurrencyTypeNzd BillingCurrencyType = "NZD"
	BillingCurrencyTypeSek BillingCurrencyType = "SEK"
	BillingCurrencyTypeSgd BillingCurrencyType = "SGD"
	BillingCurrencyTypeUsd BillingCurrencyType = "USD"
)

func BillingCurrencyTypeChoices() []string {
	return []string{"AUD", "CAD", "CHF", "DKK", "EUR", "GBP", "JPY", "NOK", "NZD", "SEK", "SGD", "USD"}
}

type BillingEmail struct {
	Email string `json:"email"`
}
type CardInfo struct {
	Brand       string `json:"brand"`
	CardId      string `json:"card_id"`
	Country     string `json:"country"`
	CountryCode string `json:"country_code"`
	ExpMonth    int    `json:"exp_month"`
	ExpYear     int    `json:"exp_year"`
	Last4       string `json:"last4"`
	Name        string `json:"name"`
	UserEmail   string `json:"user_email"`
}
type Elasticsearch struct {
	EolDate string `json:"eol_date"`
	Version string `json:"version"`
}
type EndOfLifeExtension struct {
	Elasticsearch *Elasticsearch `json:"elasticsearch,omitempty"`
}
type Event struct {
	Actor       string    `json:"actor"`
	EventDesc   string    `json:"event_desc"`
	EventType   string    `json:"event_type"`
	Id          string    `json:"id"`
	ServiceName string    `json:"service_name"`
	Time        time.Time `json:"time"`
}
type GroupUser struct {
	MemberType  MemberType `json:"member_type,omitempty"`
	RealName    string     `json:"real_name"`
	UserEmail   string     `json:"user_email"`
	UserGroupId string     `json:"user_group_id"`
}
type Invitation struct {
	InviteTime        time.Time  `json:"invite_time"`
	InvitedUserEmail  string     `json:"invited_user_email"`
	InvitingUserEmail string     `json:"inviting_user_email"`
	MemberType        MemberType `json:"member_type,omitempty"`
}
type InviteDetails struct {
	UserEmail string `json:"user_email"`
}
type listProjectVpcPeeringConnectionTypesOut struct {
	VpcPeeringConnectionTypes []VpcPeeringConnectionType `json:"vpc_peering_connection_types"`
}
type MemberType string

const (
	MemberTypeAdmin     MemberType = "admin"
	MemberTypeDeveloper MemberType = "developer"
	MemberTypeOperator  MemberType = "operator"
	MemberTypeReadOnly  MemberType = "read_only"
)

func MemberTypeChoices() []string {
	return []string{"admin", "developer", "operator", "read_only"}
}

type PrivatelinkAvailability struct {
	CloudName string `json:"cloud_name"`
	PriceUsd  string `json:"price_usd"`
}
type Project struct {
	AccountId             string              `json:"account_id"`
	AccountName           string              `json:"account_name,omitempty"`
	AddressLines          []string            `json:"address_lines"`
	AvailableCredits      string              `json:"available_credits,omitempty"`
	BillingAddress        string              `json:"billing_address"`
	BillingCurrency       BillingCurrencyType `json:"billing_currency,omitempty"`
	BillingEmails         []BillingEmail      `json:"billing_emails"`
	BillingExtraText      string              `json:"billing_extra_text,omitempty"`
	BillingGroupId        string              `json:"billing_group_id"`
	BillingGroupName      string              `json:"billing_group_name"`
	CardInfo              *CardInfo           `json:"card_info,omitempty"`
	City                  string              `json:"city,omitempty"`
	Company               string              `json:"company,omitempty"`
	Country               string              `json:"country"`
	CountryCode           string              `json:"country_code"`
	DefaultCloud          string              `json:"default_cloud"`
	EndOfLifeExtension    *EndOfLifeExtension `json:"end_of_life_extension,omitempty"`
	EstimatedBalance      string              `json:"estimated_balance"`
	EstimatedBalanceLocal string              `json:"estimated_balance_local,omitempty"`
	Features              map[string]any      `json:"features,omitempty"`
	OrganizationId        string              `json:"organization_id"`
	PaymentMethod         string              `json:"payment_method"`
	ProjectName           string              `json:"project_name"`
	State                 string              `json:"state,omitempty"`
	Tags                  map[string]string   `json:"tags,omitempty"`
	TechEmails            []BillingEmail      `json:"tech_emails"`
	TenantId              string              `json:"tenant_id,omitempty"`
	TrialExpirationTime   *time.Time          `json:"trial_expiration_time,omitempty"`
	VatId                 string              `json:"vat_id"`
	ZipCode               string              `json:"zip_code,omitempty"`
}
type projectAlertsListOut struct {
	Alerts []Alert `json:"alerts"`
}
type ProjectCreateIn struct {
	AccountId                    string              `json:"account_id,omitempty"`
	AddAccountOwnersAdminAccess  *bool               `json:"add_account_owners_admin_access,omitempty"`
	AddressLines                 []string            `json:"address_lines"`
	BillingAddress               string              `json:"billing_address,omitempty"`
	BillingCurrency              BillingCurrencyType `json:"billing_currency,omitempty"`
	BillingEmails                []BillingEmail      `json:"billing_emails"`
	BillingExtraText             string              `json:"billing_extra_text,omitempty"`
	BillingGroupId               string              `json:"billing_group_id,omitempty"`
	CardId                       string              `json:"card_id,omitempty"`
	City                         string              `json:"city,omitempty"`
	Cloud                        string              `json:"cloud,omitempty"`
	Company                      string              `json:"company,omitempty"`
	CopyFromProject              string              `json:"copy_from_project,omitempty"`
	CopyTags                     *bool               `json:"copy_tags,omitempty"`
	CountryCode                  string              `json:"country_code,omitempty"`
	Project                      string              `json:"project"`
	State                        string              `json:"state,omitempty"`
	Tags                         map[string]string   `json:"tags,omitempty"`
	TechEmails                   []BillingEmail      `json:"tech_emails"`
	UseSourceProjectBillingGroup *bool               `json:"use_source_project_billing_group,omitempty"`
	VatId                        string              `json:"vat_id,omitempty"`
	ZipCode                      string              `json:"zip_code,omitempty"`
}
type projectCreateOut struct {
	Project *Project `json:"project"`
}
type projectGenerateSbomDownloadUrlOut struct {
	DownloadUrl string `json:"download_url"`
}
type projectGetEventLogsOut struct {
	Events []Event `json:"events"`
}
type projectGetOut struct {
	Project *Project `json:"project"`
}
type projectInviteAcceptOut struct {
	InviteDetails *InviteDetails `json:"invite_details"`
}
type ProjectInviteIn struct {
	MemberType MemberType `json:"member_type,omitempty"`
	UserEmail  string     `json:"user_email"`
}
type ProjectListOut struct {
	ProjectMembership  *ProjectMembership  `json:"project_membership"`
	ProjectMemberships *ProjectMemberships `json:"project_memberships,omitempty"`
	Projects           []Project           `json:"projects"`
}
type ProjectMembership struct {
	Any MemberType `json:"ANY,omitempty"`
}
type ProjectMemberships struct {
	Any []string `json:"ANY"`
}
type projectPrivatelinkAvailabilityListOut struct {
	PrivatelinkAvailability []PrivatelinkAvailability `json:"privatelink_availability"`
}
type projectTagsListOut struct {
	Tags map[string]string `json:"tags,omitempty"`
}
type ProjectTagsReplaceIn struct {
	Tags map[string]string `json:"tags,omitempty"`
}
type ProjectTagsUpdateIn struct {
	Tags map[string]string `json:"tags,omitempty"`
}
type ProjectUpdateIn struct {
	AccountId                   string              `json:"account_id,omitempty"`
	AddAccountOwnersAdminAccess *bool               `json:"add_account_owners_admin_access,omitempty"`
	AddressLines                []string            `json:"address_lines"`
	BillingAddress              string              `json:"billing_address,omitempty"`
	BillingCurrency             BillingCurrencyType `json:"billing_currency,omitempty"`
	BillingEmails               []BillingEmail      `json:"billing_emails"`
	BillingExtraText            string              `json:"billing_extra_text,omitempty"`
	BillingGroupId              string              `json:"billing_group_id,omitempty"`
	CardId                      string              `json:"card_id,omitempty"`
	City                        string              `json:"city,omitempty"`
	Cloud                       string              `json:"cloud,omitempty"`
	Company                     string              `json:"company,omitempty"`
	CountryCode                 string              `json:"country_code,omitempty"`
	ProjectName                 string              `json:"project_name,omitempty"`
	State                       string              `json:"state,omitempty"`
	Tags                        map[string]string   `json:"tags,omitempty"`
	TechEmails                  []BillingEmail      `json:"tech_emails"`
	VatId                       string              `json:"vat_id,omitempty"`
	ZipCode                     string              `json:"zip_code,omitempty"`
}
type projectUpdateOut struct {
	Project *Project `json:"project"`
}
type ProjectUserListOut struct {
	GroupUsers  []GroupUser  `json:"group_users"`
	Invitations []Invitation `json:"invitations"`
	Users       []User       `json:"users"`
}
type ProjectUserUpdateIn struct {
	MemberType MemberType `json:"member_type,omitempty"`
}
type User struct {
	Auth           []string   `json:"auth"`
	BillingContact bool       `json:"billing_contact"`
	CreateTime     time.Time  `json:"create_time"`
	MemberType     MemberType `json:"member_type,omitempty"`
	RealName       string     `json:"real_name,omitempty"`
	TeamId         string     `json:"team_id"`
	TeamName       string     `json:"team_name"`
	UserEmail      string     `json:"user_email"`
}
type VpcPeeringConnectionType struct {
	CloudName                string                                           `json:"cloud_name"`
	PriceUsd                 string                                           `json:"price_usd"`
	VpcPeeringConnectionType VpcPeeringConnectionTypeVpcPeeringConnectionType `json:"vpc_peering_connection_type"`
}
type VpcPeeringConnectionTypeVpcPeeringConnectionType string

const (
	VpcPeeringConnectionTypeVpcPeeringConnectionTypeAwsTgwVpcAttachment     VpcPeeringConnectionTypeVpcPeeringConnectionType = "aws-tgw-vpc-attachment"
	VpcPeeringConnectionTypeVpcPeeringConnectionTypeAwsVpcPeeringConnection VpcPeeringConnectionTypeVpcPeeringConnectionType = "aws-vpc-peering-connection"
	VpcPeeringConnectionTypeVpcPeeringConnectionTypeAzureVnetPeering        VpcPeeringConnectionTypeVpcPeeringConnectionType = "azure-vnet-peering"
	VpcPeeringConnectionTypeVpcPeeringConnectionTypeGoogleVpcPeering        VpcPeeringConnectionTypeVpcPeeringConnectionType = "google-vpc-peering"
	VpcPeeringConnectionTypeVpcPeeringConnectionTypeUpcloudVpcPeering       VpcPeeringConnectionTypeVpcPeeringConnectionType = "upcloud-vpc-peering"
)
