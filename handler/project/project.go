// Code generated by Aiven. DO NOT EDIT.

package project

import (
	"context"
	"encoding/json"
	"fmt"
	"net/url"
	"time"
)

type Handler interface {
	// ListProjectVpcPeeringConnectionTypes list VPC peering connection types for a project
	// GET /v1/project/{project}/vpc-peering-connection-types
	// https://api.aiven.io/doc/#tag/Project/operation/ListProjectVpcPeeringConnectionTypes
	ListProjectVpcPeeringConnectionTypes(ctx context.Context, project string) ([]VpcPeeringConnectionTypeOut, error)

	// ProjectAlertsList list active alerts for a project
	// GET /v1/project/{project}/alerts
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectAlertsList
	ProjectAlertsList(ctx context.Context, project string) ([]AlertOut, error)

	// ProjectCreate create a project
	// POST /v1/project
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectCreate
	ProjectCreate(ctx context.Context, in *ProjectCreateIn) (*ProjectCreateOut, error)

	// ProjectDelete delete project
	// DELETE /v1/project/{project}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectDelete
	ProjectDelete(ctx context.Context, project string) error

	// ProjectGenerateSbomDownloadUrl generate SBOM for project
	// GET /v1/project/{project}/generate-sbom-download-url/{file_format}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectGenerateSbomDownloadUrl
	ProjectGenerateSbomDownloadUrl(ctx context.Context, project string, fileFormat string) (string, error)

	// ProjectGet get project details
	// GET /v1/project/{project}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectGet
	ProjectGet(ctx context.Context, project string) (*ProjectGetOut, error)

	// ProjectGetEventLogs get project event log entries
	// GET /v1/project/{project}/events
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectGetEventLogs
	ProjectGetEventLogs(ctx context.Context, project string) ([]EventOut, error)

	// ProjectInvite send project membership invitation
	// POST /v1/project/{project}/invite
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectInvite
	ProjectInvite(ctx context.Context, project string, in *ProjectInviteIn) error

	// ProjectInviteAccept confirm project invite
	// POST /v1/project/{project}/invite/{invite_verification_code}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectInviteAccept
	ProjectInviteAccept(ctx context.Context, project string, inviteVerificationCode string) (*ProjectInviteAcceptOut, error)

	// ProjectInviteDelete delete an invitation to a project
	// DELETE /v1/project/{project}/invite/{invited_email}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectInviteDelete
	ProjectInviteDelete(ctx context.Context, project string, invitedEmail string) error

	// ProjectKmsGetCA retrieve project CA certificate
	// GET /v1/project/{project}/kms/ca
	// https://api.aiven.io/doc/#tag/Project_Key_Management/operation/ProjectKmsGetCA
	ProjectKmsGetCA(ctx context.Context, project string) (string, error)

	// ProjectList list projects
	// GET /v1/project
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectList
	ProjectList(ctx context.Context) (*ProjectListOut, error)

	// ProjectPrivatelinkAvailabilityList list Privatelink cloud availability and prices for a project
	// GET /v1/project/{project}/privatelink-availability
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectPrivatelinkAvailabilityList
	ProjectPrivatelinkAvailabilityList(ctx context.Context, project string) ([]PrivatelinkAvailabilityOut, error)

	// ProjectTagsList list all tags attached to this project
	// GET /v1/project/{project}/tags
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectTagsList
	ProjectTagsList(ctx context.Context, project string) (map[string]string, error)

	// ProjectTagsReplace replace all project tags with a new set of tags, deleting old ones
	// PUT /v1/project/{project}/tags
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectTagsReplace
	ProjectTagsReplace(ctx context.Context, project string, in *ProjectTagsReplaceIn) error

	// ProjectTagsUpdate update one or more tags, creating ones that don't exist, and deleting ones given NULL value
	// PATCH /v1/project/{project}/tags
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectTagsUpdate
	ProjectTagsUpdate(ctx context.Context, project string, in *ProjectTagsUpdateIn) error

	// ProjectUpdate update project
	// PUT /v1/project/{project}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectUpdate
	ProjectUpdate(ctx context.Context, project string, in *ProjectUpdateIn) (*ProjectUpdateOut, error)

	// ProjectUserList list users with access to the project. May contain same user multiple times if they belong to multiple teams associated to the project
	// GET /v1/project/{project}/users
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectUserList
	ProjectUserList(ctx context.Context, project string) (*ProjectUserListOut, error)

	// ProjectUserRemove remove user from the project
	// DELETE /v1/project/{project}/user/{user_email}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectUserRemove
	ProjectUserRemove(ctx context.Context, project string, userEmail string) error

	// ProjectUserUpdate update a project user
	// PUT /v1/project/{project}/user/{user_email}
	// https://api.aiven.io/doc/#tag/Project/operation/ProjectUserUpdate
	ProjectUserUpdate(ctx context.Context, project string, userEmail string, in *ProjectUserUpdateIn) error
}

func NewHandler(doer doer) ProjectHandler {
	return ProjectHandler{doer}
}

type doer interface {
	Do(ctx context.Context, operationID, method, path string, v any) ([]byte, error)
}

type ProjectHandler struct {
	doer doer
}

func (h *ProjectHandler) ListProjectVpcPeeringConnectionTypes(ctx context.Context, project string) ([]VpcPeeringConnectionTypeOut, error) {
	path := fmt.Sprintf("/v1/project/%s/vpc-peering-connection-types", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ListProjectVpcPeeringConnectionTypes", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(listProjectVpcPeeringConnectionTypesOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.VpcPeeringConnectionTypes, nil
}
func (h *ProjectHandler) ProjectAlertsList(ctx context.Context, project string) ([]AlertOut, error) {
	path := fmt.Sprintf("/v1/project/%s/alerts", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ProjectAlertsList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(projectAlertsListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Alerts, nil
}
func (h *ProjectHandler) ProjectCreate(ctx context.Context, in *ProjectCreateIn) (*ProjectCreateOut, error) {
	path := fmt.Sprintf("/v1/project")
	b, err := h.doer.Do(ctx, "ProjectCreate", "POST", path, in)
	if err != nil {
		return nil, err
	}
	out := new(projectCreateOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.Project, nil
}
func (h *ProjectHandler) ProjectDelete(ctx context.Context, project string) error {
	path := fmt.Sprintf("/v1/project/%s", url.PathEscape(project))
	_, err := h.doer.Do(ctx, "ProjectDelete", "DELETE", path, nil)
	return err
}
func (h *ProjectHandler) ProjectGenerateSbomDownloadUrl(ctx context.Context, project string, fileFormat string) (string, error) {
	path := fmt.Sprintf("/v1/project/%s/generate-sbom-download-url/%s", url.PathEscape(project), url.PathEscape(fileFormat))
	b, err := h.doer.Do(ctx, "ProjectGenerateSbomDownloadUrl", "GET", path, nil)
	if err != nil {
		return "", err
	}
	out := new(projectGenerateSbomDownloadUrlOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return "", err
	}
	return out.DownloadUrl, nil
}
func (h *ProjectHandler) ProjectGet(ctx context.Context, project string) (*ProjectGetOut, error) {
	path := fmt.Sprintf("/v1/project/%s", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ProjectGet", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(projectGetOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.Project, nil
}
func (h *ProjectHandler) ProjectGetEventLogs(ctx context.Context, project string) ([]EventOut, error) {
	path := fmt.Sprintf("/v1/project/%s/events", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ProjectGetEventLogs", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(projectGetEventLogsOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Events, nil
}
func (h *ProjectHandler) ProjectInvite(ctx context.Context, project string, in *ProjectInviteIn) error {
	path := fmt.Sprintf("/v1/project/%s/invite", url.PathEscape(project))
	_, err := h.doer.Do(ctx, "ProjectInvite", "POST", path, in)
	return err
}
func (h *ProjectHandler) ProjectInviteAccept(ctx context.Context, project string, inviteVerificationCode string) (*ProjectInviteAcceptOut, error) {
	path := fmt.Sprintf("/v1/project/%s/invite/%s", url.PathEscape(project), url.PathEscape(inviteVerificationCode))
	b, err := h.doer.Do(ctx, "ProjectInviteAccept", "POST", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(projectInviteAcceptOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.InviteDetails, nil
}
func (h *ProjectHandler) ProjectInviteDelete(ctx context.Context, project string, invitedEmail string) error {
	path := fmt.Sprintf("/v1/project/%s/invite/%s", url.PathEscape(project), url.PathEscape(invitedEmail))
	_, err := h.doer.Do(ctx, "ProjectInviteDelete", "DELETE", path, nil)
	return err
}
func (h *ProjectHandler) ProjectKmsGetCA(ctx context.Context, project string) (string, error) {
	path := fmt.Sprintf("/v1/project/%s/kms/ca", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ProjectKmsGetCA", "GET", path, nil)
	if err != nil {
		return "", err
	}
	out := new(projectKmsGetCaOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return "", err
	}
	return out.Certificate, nil
}
func (h *ProjectHandler) ProjectList(ctx context.Context) (*ProjectListOut, error) {
	path := fmt.Sprintf("/v1/project")
	b, err := h.doer.Do(ctx, "ProjectList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(ProjectListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *ProjectHandler) ProjectPrivatelinkAvailabilityList(ctx context.Context, project string) ([]PrivatelinkAvailabilityOut, error) {
	path := fmt.Sprintf("/v1/project/%s/privatelink-availability", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ProjectPrivatelinkAvailabilityList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(projectPrivatelinkAvailabilityListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.PrivatelinkAvailability, nil
}
func (h *ProjectHandler) ProjectTagsList(ctx context.Context, project string) (map[string]string, error) {
	path := fmt.Sprintf("/v1/project/%s/tags", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ProjectTagsList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(projectTagsListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Tags, nil
}
func (h *ProjectHandler) ProjectTagsReplace(ctx context.Context, project string, in *ProjectTagsReplaceIn) error {
	path := fmt.Sprintf("/v1/project/%s/tags", url.PathEscape(project))
	_, err := h.doer.Do(ctx, "ProjectTagsReplace", "PUT", path, in)
	return err
}
func (h *ProjectHandler) ProjectTagsUpdate(ctx context.Context, project string, in *ProjectTagsUpdateIn) error {
	path := fmt.Sprintf("/v1/project/%s/tags", url.PathEscape(project))
	_, err := h.doer.Do(ctx, "ProjectTagsUpdate", "PATCH", path, in)
	return err
}
func (h *ProjectHandler) ProjectUpdate(ctx context.Context, project string, in *ProjectUpdateIn) (*ProjectUpdateOut, error) {
	path := fmt.Sprintf("/v1/project/%s", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ProjectUpdate", "PUT", path, in)
	if err != nil {
		return nil, err
	}
	out := new(projectUpdateOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.Project, nil
}
func (h *ProjectHandler) ProjectUserList(ctx context.Context, project string) (*ProjectUserListOut, error) {
	path := fmt.Sprintf("/v1/project/%s/users", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ProjectUserList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(ProjectUserListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *ProjectHandler) ProjectUserRemove(ctx context.Context, project string, userEmail string) error {
	path := fmt.Sprintf("/v1/project/%s/user/%s", url.PathEscape(project), url.PathEscape(userEmail))
	_, err := h.doer.Do(ctx, "ProjectUserRemove", "DELETE", path, nil)
	return err
}
func (h *ProjectHandler) ProjectUserUpdate(ctx context.Context, project string, userEmail string, in *ProjectUserUpdateIn) error {
	path := fmt.Sprintf("/v1/project/%s/user/%s", url.PathEscape(project), url.PathEscape(userEmail))
	_, err := h.doer.Do(ctx, "ProjectUserUpdate", "PUT", path, in)
	return err
}

type AlertOut struct {
	CreateTime  time.Time `json:"create_time"`
	Event       string    `json:"event"`
	NodeName    *string   `json:"node_name,omitempty"`
	ProjectName string    `json:"project_name"`
	ServiceName *string   `json:"service_name,omitempty"`
	ServiceType *string   `json:"service_type,omitempty"`
	Severity    string    `json:"severity"`
}
type AnyType string

const (
	AnyTypeAdmin     AnyType = "admin"
	AnyTypeDeveloper AnyType = "developer"
	AnyTypeOperator  AnyType = "operator"
	AnyTypeReadOnly  AnyType = "read_only"
)

func AnyTypeChoices() []string {
	return []string{"admin", "developer", "operator", "read_only"}
}

type BillingCurrencyType string

const (
	BillingCurrencyTypeAud BillingCurrencyType = "AUD"
	BillingCurrencyTypeCad BillingCurrencyType = "CAD"
	BillingCurrencyTypeChf BillingCurrencyType = "CHF"
	BillingCurrencyTypeDkk BillingCurrencyType = "DKK"
	BillingCurrencyTypeEur BillingCurrencyType = "EUR"
	BillingCurrencyTypeGbp BillingCurrencyType = "GBP"
	BillingCurrencyTypeJpy BillingCurrencyType = "JPY"
	BillingCurrencyTypeNok BillingCurrencyType = "NOK"
	BillingCurrencyTypeNzd BillingCurrencyType = "NZD"
	BillingCurrencyTypeSek BillingCurrencyType = "SEK"
	BillingCurrencyTypeSgd BillingCurrencyType = "SGD"
	BillingCurrencyTypeUsd BillingCurrencyType = "USD"
)

func BillingCurrencyTypeChoices() []string {
	return []string{"AUD", "CAD", "CHF", "DKK", "EUR", "GBP", "JPY", "NOK", "NZD", "SEK", "SGD", "USD"}
}

type BillingEmailIn struct {
	Email string `json:"email"`
}
type BillingEmailOut struct {
	Email string `json:"email"`
}
type CardInfoOut struct {
	Brand       string `json:"brand"`
	CardId      string `json:"card_id"`
	Country     string `json:"country"`
	CountryCode string `json:"country_code"`
	ExpMonth    int    `json:"exp_month"`
	ExpYear     int    `json:"exp_year"`
	Last4       string `json:"last4"`
	Name        string `json:"name"`
	UserEmail   string `json:"user_email"`
}
type ElasticsearchOut struct {
	EolDate string `json:"eol_date"`
	Version string `json:"version"`
}
type EndOfLifeExtensionOut struct {
	Elasticsearch *ElasticsearchOut `json:"elasticsearch,omitempty"`
}
type EventOut struct {
	Actor       string `json:"actor"`
	EventDesc   string `json:"event_desc"`
	EventType   string `json:"event_type"`
	Id          string `json:"id"`
	ServiceName string `json:"service_name"`
	Time        string `json:"time"`
}
type GroupUserOut struct {
	MemberType  MemberType `json:"member_type"`
	RealName    string     `json:"real_name"`
	UserEmail   string     `json:"user_email"`
	UserGroupId string     `json:"user_group_id"`
}
type InvitationOut struct {
	InviteTime        time.Time  `json:"invite_time"`
	InvitedUserEmail  string     `json:"invited_user_email"`
	InvitingUserEmail string     `json:"inviting_user_email"`
	MemberType        MemberType `json:"member_type"`
}
type MemberType string

const (
	MemberTypeAdmin     MemberType = "admin"
	MemberTypeDeveloper MemberType = "developer"
	MemberTypeOperator  MemberType = "operator"
	MemberTypeReadOnly  MemberType = "read_only"
)

func MemberTypeChoices() []string {
	return []string{"admin", "developer", "operator", "read_only"}
}

type PrivatelinkAvailabilityOut struct {
	CloudName string `json:"cloud_name"`
	PriceUsd  string `json:"price_usd"`
}
type ProjectCreateIn struct {
	AccountId                    *string             `json:"account_id,omitempty"`
	AddAccountOwnersAdminAccess  *bool               `json:"add_account_owners_admin_access,omitempty"`
	AddressLines                 *[]string           `json:"address_lines,omitempty"`
	BasePort                     *int                `json:"base_port,omitempty"`
	BillingAddress               *string             `json:"billing_address,omitempty"`
	BillingCurrency              BillingCurrencyType `json:"billing_currency,omitempty"`
	BillingEmails                *[]BillingEmailIn   `json:"billing_emails,omitempty"`
	BillingExtraText             *string             `json:"billing_extra_text,omitempty"`
	BillingGroupId               *string             `json:"billing_group_id,omitempty"`
	CardId                       *string             `json:"card_id,omitempty"`
	City                         *string             `json:"city,omitempty"`
	Cloud                        *string             `json:"cloud,omitempty"`
	Company                      *string             `json:"company,omitempty"`
	CopyFromProject              *string             `json:"copy_from_project,omitempty"`
	CopyTags                     *bool               `json:"copy_tags,omitempty"`
	CountryCode                  *string             `json:"country_code,omitempty"`
	Project                      string              `json:"project"`
	State                        *string             `json:"state,omitempty"`
	Tags                         *map[string]string  `json:"tags,omitempty"`
	TechEmails                   *[]TechEmailIn      `json:"tech_emails,omitempty"`
	UseSourceProjectBillingGroup *bool               `json:"use_source_project_billing_group,omitempty"`
	VatId                        *string             `json:"vat_id,omitempty"`
	ZipCode                      *string             `json:"zip_code,omitempty"`
}
type ProjectCreateOut struct {
	AccountId             string                 `json:"account_id"`
	AccountName           *string                `json:"account_name,omitempty"`
	AddressLines          []string               `json:"address_lines,omitempty"`
	AvailableCredits      *string                `json:"available_credits,omitempty"`
	BillingAddress        string                 `json:"billing_address"`
	BillingCurrency       BillingCurrencyType    `json:"billing_currency,omitempty"`
	BillingEmails         []BillingEmailOut      `json:"billing_emails"`
	BillingExtraText      *string                `json:"billing_extra_text,omitempty"`
	BillingGroupId        string                 `json:"billing_group_id"`
	BillingGroupName      string                 `json:"billing_group_name"`
	CardInfo              *CardInfoOut           `json:"card_info,omitempty"`
	City                  *string                `json:"city,omitempty"`
	Company               *string                `json:"company,omitempty"`
	Country               string                 `json:"country"`
	CountryCode           string                 `json:"country_code"`
	DefaultCloud          string                 `json:"default_cloud"`
	EndOfLifeExtension    *EndOfLifeExtensionOut `json:"end_of_life_extension,omitempty"`
	EstimatedBalance      string                 `json:"estimated_balance"`
	EstimatedBalanceLocal *string                `json:"estimated_balance_local,omitempty"`
	Features              map[string]any         `json:"features,omitempty"`
	OrganizationId        string                 `json:"organization_id"`
	PaymentMethod         string                 `json:"payment_method"`
	ProjectName           string                 `json:"project_name"`
	State                 *string                `json:"state,omitempty"`
	Tags                  map[string]string      `json:"tags,omitempty"`
	TechEmails            []TechEmailOut         `json:"tech_emails,omitempty"`
	TenantId              *string                `json:"tenant_id,omitempty"`
	TrialExpirationTime   *time.Time             `json:"trial_expiration_time,omitempty"`
	VatId                 string                 `json:"vat_id"`
	ZipCode               *string                `json:"zip_code,omitempty"`
}
type ProjectGetOut struct {
	AccountId             string                 `json:"account_id"`
	AccountName           *string                `json:"account_name,omitempty"`
	AddressLines          []string               `json:"address_lines,omitempty"`
	AvailableCredits      *string                `json:"available_credits,omitempty"`
	BillingAddress        string                 `json:"billing_address"`
	BillingCurrency       BillingCurrencyType    `json:"billing_currency,omitempty"`
	BillingEmails         []BillingEmailOut      `json:"billing_emails"`
	BillingExtraText      *string                `json:"billing_extra_text,omitempty"`
	BillingGroupId        string                 `json:"billing_group_id"`
	BillingGroupName      string                 `json:"billing_group_name"`
	CardInfo              *CardInfoOut           `json:"card_info,omitempty"`
	City                  *string                `json:"city,omitempty"`
	Company               *string                `json:"company,omitempty"`
	Country               string                 `json:"country"`
	CountryCode           string                 `json:"country_code"`
	DefaultCloud          string                 `json:"default_cloud"`
	EndOfLifeExtension    *EndOfLifeExtensionOut `json:"end_of_life_extension,omitempty"`
	EstimatedBalance      string                 `json:"estimated_balance"`
	EstimatedBalanceLocal *string                `json:"estimated_balance_local,omitempty"`
	Features              map[string]any         `json:"features,omitempty"`
	OrganizationId        string                 `json:"organization_id"`
	PaymentMethod         string                 `json:"payment_method"`
	ProjectName           string                 `json:"project_name"`
	State                 *string                `json:"state,omitempty"`
	Tags                  map[string]string      `json:"tags,omitempty"`
	TechEmails            []TechEmailOut         `json:"tech_emails,omitempty"`
	TenantId              *string                `json:"tenant_id,omitempty"`
	TrialExpirationTime   *time.Time             `json:"trial_expiration_time,omitempty"`
	VatId                 string                 `json:"vat_id"`
	ZipCode               *string                `json:"zip_code,omitempty"`
}
type ProjectInviteAcceptOut struct {
	UserEmail string `json:"user_email"`
}
type ProjectInviteIn struct {
	MemberType MemberType `json:"member_type,omitempty"`
	UserEmail  string     `json:"user_email"`
}
type ProjectListOut struct {
	ProjectMembership  ProjectMembershipOut   `json:"project_membership"`
	ProjectMemberships *ProjectMembershipsOut `json:"project_memberships,omitempty"`
	Projects           []ProjectOut           `json:"projects"`
}
type ProjectMembershipOut struct {
	Any AnyType `json:"ANY,omitempty"`
}
type ProjectMembershipsOut struct {
	Any []string `json:"ANY,omitempty"`
}
type ProjectOut struct {
	AccountId             string                 `json:"account_id"`
	AccountName           *string                `json:"account_name,omitempty"`
	AddressLines          []string               `json:"address_lines,omitempty"`
	AvailableCredits      *string                `json:"available_credits,omitempty"`
	BillingAddress        string                 `json:"billing_address"`
	BillingCurrency       BillingCurrencyType    `json:"billing_currency,omitempty"`
	BillingEmails         []BillingEmailOut      `json:"billing_emails"`
	BillingExtraText      *string                `json:"billing_extra_text,omitempty"`
	BillingGroupId        string                 `json:"billing_group_id"`
	BillingGroupName      string                 `json:"billing_group_name"`
	CardInfo              *CardInfoOut           `json:"card_info,omitempty"`
	City                  *string                `json:"city,omitempty"`
	Company               *string                `json:"company,omitempty"`
	Country               string                 `json:"country"`
	CountryCode           string                 `json:"country_code"`
	DefaultCloud          string                 `json:"default_cloud"`
	EndOfLifeExtension    *EndOfLifeExtensionOut `json:"end_of_life_extension,omitempty"`
	EstimatedBalance      string                 `json:"estimated_balance"`
	EstimatedBalanceLocal *string                `json:"estimated_balance_local,omitempty"`
	Features              map[string]any         `json:"features,omitempty"`
	OrganizationId        string                 `json:"organization_id"`
	PaymentMethod         string                 `json:"payment_method"`
	ProjectName           string                 `json:"project_name"`
	State                 *string                `json:"state,omitempty"`
	Tags                  map[string]string      `json:"tags,omitempty"`
	TechEmails            []TechEmailOut         `json:"tech_emails,omitempty"`
	TenantId              *string                `json:"tenant_id,omitempty"`
	TrialExpirationTime   *time.Time             `json:"trial_expiration_time,omitempty"`
	VatId                 string                 `json:"vat_id"`
	ZipCode               *string                `json:"zip_code,omitempty"`
}
type ProjectTagsReplaceIn struct {
	Tags map[string]string `json:"tags"`
}
type ProjectTagsUpdateIn struct {
	Tags map[string]string `json:"tags"`
}
type ProjectUpdateIn struct {
	AccountId                   *string             `json:"account_id,omitempty"`
	AddAccountOwnersAdminAccess *bool               `json:"add_account_owners_admin_access,omitempty"`
	AddressLines                *[]string           `json:"address_lines,omitempty"`
	BillingAddress              *string             `json:"billing_address,omitempty"`
	BillingCurrency             BillingCurrencyType `json:"billing_currency,omitempty"`
	BillingEmails               *[]BillingEmailIn   `json:"billing_emails,omitempty"`
	BillingExtraText            *string             `json:"billing_extra_text,omitempty"`
	BillingGroupId              *string             `json:"billing_group_id,omitempty"`
	CardId                      *string             `json:"card_id,omitempty"`
	City                        *string             `json:"city,omitempty"`
	Cloud                       *string             `json:"cloud,omitempty"`
	Company                     *string             `json:"company,omitempty"`
	CountryCode                 *string             `json:"country_code,omitempty"`
	ProjectName                 *string             `json:"project_name,omitempty"`
	State                       *string             `json:"state,omitempty"`
	Tags                        *map[string]string  `json:"tags,omitempty"`
	TechEmails                  *[]TechEmailIn      `json:"tech_emails,omitempty"`
	VatId                       *string             `json:"vat_id,omitempty"`
	ZipCode                     *string             `json:"zip_code,omitempty"`
}
type ProjectUpdateOut struct {
	AccountId             string                 `json:"account_id"`
	AccountName           *string                `json:"account_name,omitempty"`
	AddressLines          []string               `json:"address_lines,omitempty"`
	AvailableCredits      *string                `json:"available_credits,omitempty"`
	BillingAddress        string                 `json:"billing_address"`
	BillingCurrency       BillingCurrencyType    `json:"billing_currency,omitempty"`
	BillingEmails         []BillingEmailOut      `json:"billing_emails"`
	BillingExtraText      *string                `json:"billing_extra_text,omitempty"`
	BillingGroupId        string                 `json:"billing_group_id"`
	BillingGroupName      string                 `json:"billing_group_name"`
	CardInfo              *CardInfoOut           `json:"card_info,omitempty"`
	City                  *string                `json:"city,omitempty"`
	Company               *string                `json:"company,omitempty"`
	Country               string                 `json:"country"`
	CountryCode           string                 `json:"country_code"`
	DefaultCloud          string                 `json:"default_cloud"`
	EndOfLifeExtension    *EndOfLifeExtensionOut `json:"end_of_life_extension,omitempty"`
	EstimatedBalance      string                 `json:"estimated_balance"`
	EstimatedBalanceLocal *string                `json:"estimated_balance_local,omitempty"`
	Features              map[string]any         `json:"features,omitempty"`
	OrganizationId        string                 `json:"organization_id"`
	PaymentMethod         string                 `json:"payment_method"`
	ProjectName           string                 `json:"project_name"`
	State                 *string                `json:"state,omitempty"`
	Tags                  map[string]string      `json:"tags,omitempty"`
	TechEmails            []TechEmailOut         `json:"tech_emails,omitempty"`
	TenantId              *string                `json:"tenant_id,omitempty"`
	TrialExpirationTime   *time.Time             `json:"trial_expiration_time,omitempty"`
	VatId                 string                 `json:"vat_id"`
	ZipCode               *string                `json:"zip_code,omitempty"`
}
type ProjectUserListOut struct {
	GroupUsers  []GroupUserOut  `json:"group_users"`
	Invitations []InvitationOut `json:"invitations"`
	Users       []UserOut       `json:"users"`
}
type ProjectUserUpdateIn struct {
	MemberType MemberType `json:"member_type"`
}
type TechEmailIn struct {
	Email string `json:"email"`
}
type TechEmailOut struct {
	Email string `json:"email"`
}
type UserOut struct {
	Auth           []string   `json:"auth"`
	BillingContact bool       `json:"billing_contact"`
	CreateTime     time.Time  `json:"create_time"`
	MemberType     MemberType `json:"member_type"`
	RealName       *string    `json:"real_name,omitempty"`
	TeamId         string     `json:"team_id"`
	TeamName       string     `json:"team_name"`
	UserEmail      string     `json:"user_email"`
}
type VpcPeeringConnectionType string

const (
	VpcPeeringConnectionTypeAwsTgwVpcAttachment     VpcPeeringConnectionType = "aws-tgw-vpc-attachment"
	VpcPeeringConnectionTypeAwsVpcPeeringConnection VpcPeeringConnectionType = "aws-vpc-peering-connection"
	VpcPeeringConnectionTypeAzureVnetPeering        VpcPeeringConnectionType = "azure-vnet-peering"
	VpcPeeringConnectionTypeGoogleVpcPeering        VpcPeeringConnectionType = "google-vpc-peering"
	VpcPeeringConnectionTypeUpcloudVpcPeering       VpcPeeringConnectionType = "upcloud-vpc-peering"
)

func VpcPeeringConnectionTypeChoices() []string {
	return []string{"aws-tgw-vpc-attachment", "aws-vpc-peering-connection", "azure-vnet-peering", "google-vpc-peering", "upcloud-vpc-peering"}
}

type VpcPeeringConnectionTypeOut struct {
	CloudName                string                   `json:"cloud_name"`
	PriceUsd                 string                   `json:"price_usd"`
	VpcPeeringConnectionType VpcPeeringConnectionType `json:"vpc_peering_connection_type"`
}
type listProjectVpcPeeringConnectionTypesOut struct {
	VpcPeeringConnectionTypes []VpcPeeringConnectionTypeOut `json:"vpc_peering_connection_types"`
}
type projectAlertsListOut struct {
	Alerts []AlertOut `json:"alerts"`
}
type projectCreateOut struct {
	Project ProjectCreateOut `json:"project"`
}
type projectGenerateSbomDownloadUrlOut struct {
	DownloadUrl string `json:"download_url"`
}
type projectGetEventLogsOut struct {
	Events []EventOut `json:"events"`
}
type projectGetOut struct {
	Project ProjectGetOut `json:"project"`
}
type projectInviteAcceptOut struct {
	InviteDetails ProjectInviteAcceptOut `json:"invite_details"`
}
type projectKmsGetCaOut struct {
	Certificate string `json:"certificate"`
}
type projectPrivatelinkAvailabilityListOut struct {
	PrivatelinkAvailability []PrivatelinkAvailabilityOut `json:"privatelink_availability"`
}
type projectTagsListOut struct {
	Tags map[string]string `json:"tags,omitempty"`
}
type projectUpdateOut struct {
	Project ProjectUpdateOut `json:"project"`
}
