// Code generated by Aiven. DO NOT EDIT.

package service

import (
	"context"
	"encoding/json"
	"fmt"
	"net/url"
	"time"
)

type Handler interface {
	// ListProjectServiceTypes list service types for a project
	// GET /v1/project/{project}/service_types
	// https://api.aiven.io/doc/#tag/Service/operation/ListProjectServiceTypes
	ListProjectServiceTypes(ctx context.Context, project string) (*ListProjectServiceTypesOut, error)

	// ListPublicServiceTypes list publicly available service types
	// GET /v1/service_types
	// https://api.aiven.io/doc/#tag/Service/operation/ListPublicServiceTypes
	ListPublicServiceTypes(ctx context.Context) (*ListPublicServiceTypesOut, error)

	// ListServiceVersions list service versions
	// GET /v1/service_versions
	// https://api.aiven.io/doc/#tag/Service/operation/ListServiceVersions
	ListServiceVersions(ctx context.Context) ([]ServiceVersionOut, error)

	// ProjectGetServiceLogs get service log entries
	// POST /v1/project/{project}/service/{service_name}/logs
	// https://api.aiven.io/doc/#tag/Service/operation/ProjectGetServiceLogs
	ProjectGetServiceLogs(ctx context.Context, project string, serviceName string, in *ProjectGetServiceLogsIn) (*ProjectGetServiceLogsOut, error)

	// ProjectServiceTagsList list all tags attached to the service
	// GET /v1/project/{project}/service/{service_name}/tags
	// https://api.aiven.io/doc/#tag/Service/operation/ProjectServiceTagsList
	ProjectServiceTagsList(ctx context.Context, project string, serviceName string) (map[string]string, error)

	// ProjectServiceTagsReplace replace all project tags with a new set of tags, deleting old ones
	// PUT /v1/project/{project}/service/{service_name}/tags
	// https://api.aiven.io/doc/#tag/Service/operation/ProjectServiceTagsReplace
	ProjectServiceTagsReplace(ctx context.Context, project string, serviceName string, in *ProjectServiceTagsReplaceIn) error

	// ProjectServiceTagsUpdate update one or more tags, creating ones that don't exist, and deleting ones given NULL value
	// PATCH /v1/project/{project}/service/{service_name}/tags
	// https://api.aiven.io/doc/#tag/Service/operation/ProjectServiceTagsUpdate
	ProjectServiceTagsUpdate(ctx context.Context, project string, serviceName string, in *ProjectServiceTagsUpdateIn) error

	// ServiceAlertsList list active alerts for service
	// GET /v1/project/{project}/service/{service_name}/alerts
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceAlertsList
	ServiceAlertsList(ctx context.Context, project string, serviceName string) ([]AlertOut, error)

	// ServiceBackupToAnotherRegionReport get service's backup to another region information
	// POST /v1/project/{project}/service/{service_name}/backup_to_another_region/report
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceBackupToAnotherRegionReport
	ServiceBackupToAnotherRegionReport(ctx context.Context, project string, serviceName string, in *ServiceBackupToAnotherRegionReportIn) (map[string]any, error)

	// ServiceBackupsGet get service backup information
	// GET /v1/project/{project}/service/{service_name}/backups
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceBackupsGet
	ServiceBackupsGet(ctx context.Context, project string, serviceName string) ([]BackupOut, error)

	// ServiceCancelQuery cancel specified query from service
	// POST /v1/project/{project}/service/{service_name}/query/cancel
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceCancelQuery
	ServiceCancelQuery(ctx context.Context, project string, serviceName string, in *ServiceCancelQueryIn) (bool, error)

	// ServiceCreate create a service
	// POST /v1/project/{project}/service
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceCreate
	ServiceCreate(ctx context.Context, project string, in *ServiceCreateIn) (*ServiceCreateOut, error)

	// ServiceDatabaseCreate create a new logical database for service
	// POST /v1/project/{project}/service/{service_name}/db
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceDatabaseCreate
	ServiceDatabaseCreate(ctx context.Context, project string, serviceName string, in *ServiceDatabaseCreateIn) error

	// ServiceDatabaseDelete delete a logical database
	// DELETE /v1/project/{project}/service/{service_name}/db/{dbname}
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceDatabaseDelete
	ServiceDatabaseDelete(ctx context.Context, project string, serviceName string, dbname string) error

	// ServiceDatabaseList list service databases
	// GET /v1/project/{project}/service/{service_name}/db
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceDatabaseList
	ServiceDatabaseList(ctx context.Context, project string, serviceName string) ([]DatabaseOut, error)

	// ServiceDelete terminate a service
	// DELETE /v1/project/{project}/service/{service_name}
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceDelete
	ServiceDelete(ctx context.Context, project string, serviceName string) error

	// ServiceEnableWrites temporarily enable writes for a service in read-only mode. Will only work if disk usage is lower than 99.0%
	// POST /v1/project/{project}/service/{service_name}/enable-writes
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceEnableWrites
	ServiceEnableWrites(ctx context.Context, project string, serviceName string) (*string, error)

	// ServiceGet get service information
	// GET /v1/project/{project}/service/{service_name}
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceGet
	ServiceGet(ctx context.Context, project string, serviceName string) (*ServiceGetOut, error)

	// ServiceGetMigrationStatus get migration status
	// GET /v1/project/{project}/service/{service_name}/migration
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceGetMigrationStatus
	ServiceGetMigrationStatus(ctx context.Context, project string, serviceName string) (*ServiceGetMigrationStatusOut, error)

	// ServiceInfluxDBStats list stats for influxdb
	// GET /v1/project/{project}/service/{service_name}/influxdb/stats
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceInfluxDBStats
	ServiceInfluxDBStats(ctx context.Context, project string, serviceName string) (map[string]any, error)

	// ServiceKmsGetCA retrieve a service CA
	// GET /v1/project/{project}/service/{service_name}/kms/ca/{ca_name}
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceKmsGetCA
	ServiceKmsGetCA(ctx context.Context, project string, serviceName string, caName string) (string, error)

	// ServiceKmsGetKeypair retrieve service keypair
	// GET /v1/project/{project}/service/{service_name}/kms/keypairs/{keypair_name}
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceKmsGetKeypair
	ServiceKmsGetKeypair(ctx context.Context, project string, serviceName string, keypairName string) (*ServiceKmsGetKeypairOut, error)

	// ServiceList list services
	// GET /v1/project/{project}/service
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceList
	ServiceList(ctx context.Context, project string) ([]ServiceOut, error)

	// ServiceMaintenanceStart start maintenance updates
	// PUT /v1/project/{project}/service/{service_name}/maintenance/start
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceMaintenanceStart
	ServiceMaintenanceStart(ctx context.Context, project string, serviceName string) error

	// ServiceMetricsFetch fetch service metrics
	// POST /v1/project/{project}/service/{service_name}/metrics
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceMetricsFetch
	ServiceMetricsFetch(ctx context.Context, project string, serviceName string, in *ServiceMetricsFetchIn) (map[string]any, error)

	// ServiceQueryActivity fetch current queries for the service
	// POST /v1/project/{project}/service/{service_name}/query/activity
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceQueryActivity
	ServiceQueryActivity(ctx context.Context, project string, serviceName string, in *ServiceQueryActivityIn) ([]QueryOut, error)

	// ServiceQueryStatisticsReset reset service's query statistics
	// PUT /v1/project/{project}/service/{service_name}/query/stats/reset
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceQueryStatisticsReset
	ServiceQueryStatisticsReset(ctx context.Context, project string, serviceName string) ([]map[string]any, error)

	// ServiceTaskCreate create a new task for service
	// POST /v1/project/{project}/service/{service_name}/task
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceTaskCreate
	ServiceTaskCreate(ctx context.Context, project string, serviceName string, in *ServiceTaskCreateIn) (*ServiceTaskCreateOut, error)

	// ServiceTaskGet get task result
	// GET /v1/project/{project}/service/{service_name}/task/{task_id}
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceTaskGet
	ServiceTaskGet(ctx context.Context, project string, serviceName string, taskId string) (*ServiceTaskGetOut, error)

	// ServiceUpdate update service configuration
	// PUT /v1/project/{project}/service/{service_name}
	// https://api.aiven.io/doc/#tag/Service/operation/ServiceUpdate
	ServiceUpdate(ctx context.Context, project string, serviceName string, in *ServiceUpdateIn) (*ServiceUpdateOut, error)
}

func NewHandler(doer doer) ServiceHandler {
	return ServiceHandler{doer}
}

type doer interface {
	Do(ctx context.Context, operationID, method, path string, v any) ([]byte, error)
}

type ServiceHandler struct {
	doer doer
}

func (h *ServiceHandler) ListProjectServiceTypes(ctx context.Context, project string) (*ListProjectServiceTypesOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service_types", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ListProjectServiceTypes", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(listProjectServiceTypesOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.ServiceTypes, nil
}
func (h *ServiceHandler) ListPublicServiceTypes(ctx context.Context) (*ListPublicServiceTypesOut, error) {
	path := fmt.Sprintf("/v1/service_types")
	b, err := h.doer.Do(ctx, "ListPublicServiceTypes", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(listPublicServiceTypesOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.ServiceTypes, nil
}
func (h *ServiceHandler) ListServiceVersions(ctx context.Context) ([]ServiceVersionOut, error) {
	path := fmt.Sprintf("/v1/service_versions")
	b, err := h.doer.Do(ctx, "ListServiceVersions", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(listServiceVersionsOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.ServiceVersions, nil
}
func (h *ServiceHandler) ProjectGetServiceLogs(ctx context.Context, project string, serviceName string, in *ProjectGetServiceLogsIn) (*ProjectGetServiceLogsOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/logs", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ProjectGetServiceLogs", "POST", path, in)
	if err != nil {
		return nil, err
	}
	out := new(ProjectGetServiceLogsOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *ServiceHandler) ProjectServiceTagsList(ctx context.Context, project string, serviceName string) (map[string]string, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/tags", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ProjectServiceTagsList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(projectServiceTagsListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Tags, nil
}
func (h *ServiceHandler) ProjectServiceTagsReplace(ctx context.Context, project string, serviceName string, in *ProjectServiceTagsReplaceIn) error {
	path := fmt.Sprintf("/v1/project/%s/service/%s/tags", url.PathEscape(project), url.PathEscape(serviceName))
	_, err := h.doer.Do(ctx, "ProjectServiceTagsReplace", "PUT", path, in)
	return err
}
func (h *ServiceHandler) ProjectServiceTagsUpdate(ctx context.Context, project string, serviceName string, in *ProjectServiceTagsUpdateIn) error {
	path := fmt.Sprintf("/v1/project/%s/service/%s/tags", url.PathEscape(project), url.PathEscape(serviceName))
	_, err := h.doer.Do(ctx, "ProjectServiceTagsUpdate", "PATCH", path, in)
	return err
}
func (h *ServiceHandler) ServiceAlertsList(ctx context.Context, project string, serviceName string) ([]AlertOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/alerts", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceAlertsList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(serviceAlertsListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Alerts, nil
}
func (h *ServiceHandler) ServiceBackupToAnotherRegionReport(ctx context.Context, project string, serviceName string, in *ServiceBackupToAnotherRegionReportIn) (map[string]any, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/backup_to_another_region/report", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceBackupToAnotherRegionReport", "POST", path, in)
	if err != nil {
		return nil, err
	}
	out := new(serviceBackupToAnotherRegionReportOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Metrics, nil
}
func (h *ServiceHandler) ServiceBackupsGet(ctx context.Context, project string, serviceName string) ([]BackupOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/backups", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceBackupsGet", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(serviceBackupsGetOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Backups, nil
}
func (h *ServiceHandler) ServiceCancelQuery(ctx context.Context, project string, serviceName string, in *ServiceCancelQueryIn) (bool, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/query/cancel", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceCancelQuery", "POST", path, in)
	if err != nil {
		return false, err
	}
	out := new(serviceCancelQueryOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return false, err
	}
	return out.Success, nil
}
func (h *ServiceHandler) ServiceCreate(ctx context.Context, project string, in *ServiceCreateIn) (*ServiceCreateOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ServiceCreate", "POST", path, in)
	if err != nil {
		return nil, err
	}
	out := new(serviceCreateOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.Service, nil
}
func (h *ServiceHandler) ServiceDatabaseCreate(ctx context.Context, project string, serviceName string, in *ServiceDatabaseCreateIn) error {
	path := fmt.Sprintf("/v1/project/%s/service/%s/db", url.PathEscape(project), url.PathEscape(serviceName))
	_, err := h.doer.Do(ctx, "ServiceDatabaseCreate", "POST", path, in)
	return err
}
func (h *ServiceHandler) ServiceDatabaseDelete(ctx context.Context, project string, serviceName string, dbname string) error {
	path := fmt.Sprintf("/v1/project/%s/service/%s/db/%s", url.PathEscape(project), url.PathEscape(serviceName), url.PathEscape(dbname))
	_, err := h.doer.Do(ctx, "ServiceDatabaseDelete", "DELETE", path, nil)
	return err
}
func (h *ServiceHandler) ServiceDatabaseList(ctx context.Context, project string, serviceName string) ([]DatabaseOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/db", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceDatabaseList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(serviceDatabaseListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Databases, nil
}
func (h *ServiceHandler) ServiceDelete(ctx context.Context, project string, serviceName string) error {
	path := fmt.Sprintf("/v1/project/%s/service/%s", url.PathEscape(project), url.PathEscape(serviceName))
	_, err := h.doer.Do(ctx, "ServiceDelete", "DELETE", path, nil)
	return err
}
func (h *ServiceHandler) ServiceEnableWrites(ctx context.Context, project string, serviceName string) (*string, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/enable-writes", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceEnableWrites", "POST", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(serviceEnableWritesOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Until, nil
}
func (h *ServiceHandler) ServiceGet(ctx context.Context, project string, serviceName string) (*ServiceGetOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceGet", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(serviceGetOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.Service, nil
}
func (h *ServiceHandler) ServiceGetMigrationStatus(ctx context.Context, project string, serviceName string) (*ServiceGetMigrationStatusOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/migration", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceGetMigrationStatus", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(ServiceGetMigrationStatusOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *ServiceHandler) ServiceInfluxDBStats(ctx context.Context, project string, serviceName string) (map[string]any, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/influxdb/stats", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceInfluxDBStats", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(serviceInfluxDbstatsOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.DbStats, nil
}
func (h *ServiceHandler) ServiceKmsGetCA(ctx context.Context, project string, serviceName string, caName string) (string, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/kms/ca/%s", url.PathEscape(project), url.PathEscape(serviceName), url.PathEscape(caName))
	b, err := h.doer.Do(ctx, "ServiceKmsGetCA", "GET", path, nil)
	if err != nil {
		return "", err
	}
	out := new(serviceKmsGetCaOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return "", err
	}
	return out.Certificate, nil
}
func (h *ServiceHandler) ServiceKmsGetKeypair(ctx context.Context, project string, serviceName string, keypairName string) (*ServiceKmsGetKeypairOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/kms/keypairs/%s", url.PathEscape(project), url.PathEscape(serviceName), url.PathEscape(keypairName))
	b, err := h.doer.Do(ctx, "ServiceKmsGetKeypair", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(ServiceKmsGetKeypairOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *ServiceHandler) ServiceList(ctx context.Context, project string) ([]ServiceOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service", url.PathEscape(project))
	b, err := h.doer.Do(ctx, "ServiceList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(serviceListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Services, nil
}
func (h *ServiceHandler) ServiceMaintenanceStart(ctx context.Context, project string, serviceName string) error {
	path := fmt.Sprintf("/v1/project/%s/service/%s/maintenance/start", url.PathEscape(project), url.PathEscape(serviceName))
	_, err := h.doer.Do(ctx, "ServiceMaintenanceStart", "PUT", path, nil)
	return err
}
func (h *ServiceHandler) ServiceMetricsFetch(ctx context.Context, project string, serviceName string, in *ServiceMetricsFetchIn) (map[string]any, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/metrics", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceMetricsFetch", "POST", path, in)
	if err != nil {
		return nil, err
	}
	out := new(serviceMetricsFetchOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Metrics, nil
}
func (h *ServiceHandler) ServiceQueryActivity(ctx context.Context, project string, serviceName string, in *ServiceQueryActivityIn) ([]QueryOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/query/activity", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceQueryActivity", "POST", path, in)
	if err != nil {
		return nil, err
	}
	out := new(serviceQueryActivityOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Queries, nil
}
func (h *ServiceHandler) ServiceQueryStatisticsReset(ctx context.Context, project string, serviceName string) ([]map[string]any, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/query/stats/reset", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceQueryStatisticsReset", "PUT", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(serviceQueryStatisticsResetOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Queries, nil
}
func (h *ServiceHandler) ServiceTaskCreate(ctx context.Context, project string, serviceName string, in *ServiceTaskCreateIn) (*ServiceTaskCreateOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/task", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceTaskCreate", "POST", path, in)
	if err != nil {
		return nil, err
	}
	out := new(serviceTaskCreateOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.Task, nil
}
func (h *ServiceHandler) ServiceTaskGet(ctx context.Context, project string, serviceName string, taskId string) (*ServiceTaskGetOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s/task/%s", url.PathEscape(project), url.PathEscape(serviceName), url.PathEscape(taskId))
	b, err := h.doer.Do(ctx, "ServiceTaskGet", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(serviceTaskGetOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.Task, nil
}
func (h *ServiceHandler) ServiceUpdate(ctx context.Context, project string, serviceName string, in *ServiceUpdateIn) (*ServiceUpdateOut, error) {
	path := fmt.Sprintf("/v1/project/%s/service/%s", url.PathEscape(project), url.PathEscape(serviceName))
	b, err := h.doer.Do(ctx, "ServiceUpdate", "PUT", path, in)
	if err != nil {
		return nil, err
	}
	out := new(serviceUpdateOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.Service, nil
}

// AccessControlOut Service specific access controls for user. Service type specific access control rules for user. Currently only used for configuring user ACLs for Redis version 6 and above.
type AccessControlOut struct {
	DragonflyAclCategories []string `json:"dragonfly_acl_categories,omitempty"` // Command category rules
	DragonflyAclCommands   []string `json:"dragonfly_acl_commands,omitempty"`   // Rules for individual commands
	DragonflyAclKeys       []string `json:"dragonfly_acl_keys,omitempty"`       // Key access rules
	M3Group                *string  `json:"m3_group,omitempty"`                 // M3 access group to associate users with
	PgAllowReplication     *bool    `json:"pg_allow_replication,omitempty"`     // Enable REPLICATION role option
	RedisAclCategories     []string `json:"redis_acl_categories,omitempty"`     // Command category rules
	RedisAclChannels       []string `json:"redis_acl_channels,omitempty"`       // Permitted pub/sub channel patterns. Glob-style patterns defining which pub/sub channels can be accessed. If array is not defined, the default policy is used (allchannels).
	RedisAclCommands       []string `json:"redis_acl_commands,omitempty"`       // Rules for individual commands
	RedisAclKeys           []string `json:"redis_acl_keys,omitempty"`           // Key access rules
	ValkeyAclCategories    []string `json:"valkey_acl_categories,omitempty"`    // Command category rules
	ValkeyAclChannels      []string `json:"valkey_acl_channels,omitempty"`      // Permitted pub/sub channel patterns. Glob-style patterns defining which pub/sub channels can be accessed. If array is not defined, the default policy is used (allchannels).
	ValkeyAclCommands      []string `json:"valkey_acl_commands,omitempty"`      // Rules for individual commands
	ValkeyAclKeys          []string `json:"valkey_acl_keys,omitempty"`          // Key access rules
}
type AclOut struct {
	Id         *string        `json:"id,omitempty"` // ID
	Permission PermissionType `json:"permission"`   // Kafka permission
	Topic      string         `json:"topic"`        // Topic name pattern
	Username   string         `json:"username"`
}
type AdditionalRegionOut struct {
	Cloud       string  `json:"cloud"`                  // Target cloud
	PauseReason *string `json:"pause_reason,omitempty"` // Reason for pausing the backup synchronization
	Paused      *bool   `json:"paused,omitempty"`       // Indicates additional backup synchronization is paused
	Region      *string `json:"region,omitempty"`       // Cloud storage region name
}

// AggregatorOut Service type information
type AggregatorOut struct {
	DefaultVersion         *string          `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string           `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string          `json:"latest_available_version,omitempty"` // Latest available version of the service
	ServicePlans           []ServicePlanOut `json:"service_plans"`                      // List of plans available for this type of service
	UserConfigSchema       map[string]any   `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}
type AlertOut struct {
	CreateTime  time.Time `json:"create_time"`            // Event creation timestamp (ISO 8601)
	Event       string    `json:"event"`                  // Name of the alerting event
	NodeName    *string   `json:"node_name,omitempty"`    // Name of the service node
	ProjectName string    `json:"project_name"`           // Project name
	ServiceName *string   `json:"service_name,omitempty"` // Service name
	ServiceType *string   `json:"service_type,omitempty"` // Service type code
	Severity    string    `json:"severity"`               // Severity of the event
}
type AuthenticationType string

const (
	AuthenticationTypeNull                AuthenticationType = "null"
	AuthenticationTypeCachingSha2Password AuthenticationType = "caching_sha2_password"
	AuthenticationTypeMysqlNativePassword AuthenticationType = "mysql_native_password"
)

func AuthenticationTypeChoices() []string {
	return []string{"null", "caching_sha2_password", "mysql_native_password"}
}

// BackupConfigOut Backup configuration for this service plan
type BackupConfigOut struct {
	FrequentIntervalMinutes    *int             `json:"frequent_interval_minutes,omitempty"`     // Interval of taking a frequent backup in service types supporting different backup schedules
	FrequentOldestAgeMinutes   *int             `json:"frequent_oldest_age_minutes,omitempty"`   // Maximum age of the oldest frequent backup in service types supporting different backup schedules
	InfrequentIntervalMinutes  *int             `json:"infrequent_interval_minutes,omitempty"`   // Interval of taking an infrequent backup in service types supporting different backup schedules
	InfrequentOldestAgeMinutes *int             `json:"infrequent_oldest_age_minutes,omitempty"` // Maximum age of the oldest infrequent backup in service types supporting different backup schedules
	Interval                   int              `json:"interval"`                                // The interval, in hours, at which backups are generated. For some services, like PostgreSQL, this is the interval at which full snapshots are taken and continuous incremental backup stream is maintained in addition to that.
	MaxCount                   int              `json:"max_count"`                               // Maximum number of backups to keep. Zero when no backups are created.
	RecoveryMode               RecoveryModeType `json:"recovery_mode"`                           // Mechanism how backups can be restored. 'basic' means a backup is restored as is so that the system is restored to the state it was when the backup was generated. 'pitr' means point-in-time-recovery, which allows restoring the system to any state since the first available full snapshot.
}
type BackupOut struct {
	AdditionalRegions []AdditionalRegionOut `json:"additional_regions,omitempty"` // Additional backup regions, if available
	BackupName        string                `json:"backup_name"`                  // Internal name of this backup
	BackupTime        time.Time             `json:"backup_time"`                  // Backup timestamp (ISO 8601)
	DataSize          int                   `json:"data_size"`                    // Backup's original size before compression
	StorageLocation   *string               `json:"storage_location,omitempty"`   // Location where this backup is stored
}

// CassandraOut Service type information
type CassandraOut struct {
	DefaultVersion         *string          `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string           `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string          `json:"latest_available_version,omitempty"` // Latest available version of the service
	ServicePlans           []ServicePlanOut `json:"service_plans"`                      // List of plans available for this type of service
	UserConfigSchema       map[string]any   `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}

// ClickhouseOut Service type information
type ClickhouseOut struct {
	DefaultVersion         *string          `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string           `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string          `json:"latest_available_version,omitempty"` // Latest available version of the service
	ServicePlans           []ServicePlanOut `json:"service_plans"`                      // List of plans available for this type of service
	UserConfigSchema       map[string]any   `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}
type ComponentOut struct {
	Component                 string                        `json:"component"`                             // Service component name
	Host                      string                        `json:"host"`                                  // DNS name for connecting to the service component
	KafkaAuthenticationMethod KafkaAuthenticationMethodType `json:"kafka_authentication_method,omitempty"` // Kafka authentication method. This is a value specific to the 'kafka' service component
	KafkaSslCa                KafkaSslCaType                `json:"kafka_ssl_ca,omitempty"`                // Specifies if this port uses Project CA or Letsencrypt. If not specified, the default is using Project CA.This is a value specific to the 'kafka' service component.
	Path                      *string                       `json:"path,omitempty"`                        // Path component of the service URL (useful only if service component is HTTP or HTTPS endpoint)
	Port                      int                           `json:"port"`                                  // Port number for connecting to the service component
	PrivatelinkConnectionId   *string                       `json:"privatelink_connection_id,omitempty"`   // Privatelink connection ID
	Route                     RouteType                     `json:"route"`                                 // Network access route
	Ssl                       *bool                         `json:"ssl,omitempty"`                         // Whether the endpoint is encrypted or accepts plaintext. By default endpoints are always encrypted andthis property is only included for service components that may disable encryption.
	Usage                     UsageType                     `json:"usage"`                                 // DNS usage name
}
type ConnectionPoolOut struct {
	ConnectionUri string       `json:"connection_uri"`     // Connection URI for the DB pool
	Database      string       `json:"database"`           // Database name
	PoolMode      PoolModeType `json:"pool_mode"`          // PGBouncer pool mode
	PoolName      string       `json:"pool_name"`          // Connection pool name
	PoolSize      int          `json:"pool_size"`          // Size of PGBouncer's PostgreSQL side connection pool
	Username      *string      `json:"username,omitempty"` // Pool username
}
type DatabaseOut struct {
	DatabaseName string `json:"database_name"` // Database name or ID
}

// DatasetImportIn Payload to be used with dataset_import
type DatasetImportIn struct {
	DatasetName DatasetNameType `json:"dataset_name"` // Name of the dataset to import to PostgreSQL database. Used with dataset_import.
}
type DatasetNameType string

const (
	DatasetNameTypePagila DatasetNameType = "pagila"
)

func DatasetNameTypeChoices() []string {
	return []string{"pagila"}
}

// DbOut Service type information
type DbOut struct {
	DefaultVersion         *string          `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string           `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string          `json:"latest_available_version,omitempty"` // Latest available version of the service
	ServicePlans           []ServicePlanOut `json:"service_plans"`                      // List of plans available for this type of service
	UserConfigSchema       map[string]any   `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}
type DowType string

const (
	DowTypeMonday    DowType = "monday"
	DowTypeTuesday   DowType = "tuesday"
	DowTypeWednesday DowType = "wednesday"
	DowTypeThursday  DowType = "thursday"
	DowTypeFriday    DowType = "friday"
	DowTypeSaturday  DowType = "saturday"
	DowTypeSunday    DowType = "sunday"
)

func DowTypeChoices() []string {
	return []string{"monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"}
}

type DowTypeAlt string

const (
	DowTypeAltMonday    DowTypeAlt = "monday"
	DowTypeAltTuesday   DowTypeAlt = "tuesday"
	DowTypeAltWednesday DowTypeAlt = "wednesday"
	DowTypeAltThursday  DowTypeAlt = "thursday"
	DowTypeAltFriday    DowTypeAlt = "friday"
	DowTypeAltSaturday  DowTypeAlt = "saturday"
	DowTypeAltSunday    DowTypeAlt = "sunday"
	DowTypeAltNever     DowTypeAlt = "never"
)

func DowTypeAltChoices() []string {
	return []string{"monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday", "never"}
}

// DragonflyOut Service type information
type DragonflyOut struct {
	DefaultVersion         *string          `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string           `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string          `json:"latest_available_version,omitempty"` // Latest available version of the service
	ServicePlans           []ServicePlanOut `json:"service_plans"`                      // List of plans available for this type of service
	UserConfigSchema       map[string]any   `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}

// ElasticsearchOut Service type information
type ElasticsearchOut struct {
	DefaultVersion         *string          `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string           `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string          `json:"latest_available_version,omitempty"` // Latest available version of the service
	ServicePlans           []ServicePlanOut `json:"service_plans"`                      // List of plans available for this type of service
	UserConfigSchema       map[string]any   `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}

// FlinkOut Service type information
type FlinkOut struct {
	DefaultVersion         *string          `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string           `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string          `json:"latest_available_version,omitempty"` // Latest available version of the service
	ServicePlans           []ServicePlanOut `json:"service_plans"`                      // List of plans available for this type of service
	UserConfigSchema       map[string]any   `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}

// GrafanaOut Service type information
type GrafanaOut struct {
	DefaultVersion         *string          `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string           `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string          `json:"latest_available_version,omitempty"` // Latest available version of the service
	ServicePlans           []ServicePlanOut `json:"service_plans"`                      // List of plans available for this type of service
	UserConfigSchema       map[string]any   `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}

// InfluxdbOut Service type information
type InfluxdbOut struct {
	DefaultVersion         *string          `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string           `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string          `json:"latest_available_version,omitempty"` // Latest available version of the service
	ServicePlans           []ServicePlanOut `json:"service_plans"`                      // List of plans available for this type of service
	UserConfigSchema       map[string]any   `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}

// IntegrationStatusOut Integration status
type IntegrationStatusOut struct {
	State          StateOut `json:"state"`            // Service integration state
	StatusUserDesc string   `json:"status_user_desc"` // Integration status description
}
type IntegrationStatusType string

const (
	IntegrationStatusTypeFailed   IntegrationStatusType = "failed"
	IntegrationStatusTypeInactive IntegrationStatusType = "inactive"
	IntegrationStatusTypeRunning  IntegrationStatusType = "running"
	IntegrationStatusTypeStarting IntegrationStatusType = "starting"
	IntegrationStatusTypeUnknown  IntegrationStatusType = "unknown"
)

func IntegrationStatusTypeChoices() []string {
	return []string{"failed", "inactive", "running", "starting", "unknown"}
}

type IntegrationType string

const (
	IntegrationTypeAlertmanager                      IntegrationType = "alertmanager"
	IntegrationTypeAutoscaler                        IntegrationType = "autoscaler"
	IntegrationTypeCaching                           IntegrationType = "caching"
	IntegrationTypeCassandraCrossServiceCluster      IntegrationType = "cassandra_cross_service_cluster"
	IntegrationTypeClickhouseCredentials             IntegrationType = "clickhouse_credentials"
	IntegrationTypeClickhouseKafka                   IntegrationType = "clickhouse_kafka"
	IntegrationTypeClickhousePostgresql              IntegrationType = "clickhouse_postgresql"
	IntegrationTypeDashboard                         IntegrationType = "dashboard"
	IntegrationTypeDatadog                           IntegrationType = "datadog"
	IntegrationTypeDatasource                        IntegrationType = "datasource"
	IntegrationTypeExternalAwsCloudwatchLogs         IntegrationType = "external_aws_cloudwatch_logs"
	IntegrationTypeExternalAwsCloudwatchMetrics      IntegrationType = "external_aws_cloudwatch_metrics"
	IntegrationTypeExternalElasticsearchLogs         IntegrationType = "external_elasticsearch_logs"
	IntegrationTypeExternalGoogleCloudLogging        IntegrationType = "external_google_cloud_logging"
	IntegrationTypeExternalOpensearchLogs            IntegrationType = "external_opensearch_logs"
	IntegrationTypeFlink                             IntegrationType = "flink"
	IntegrationTypeFlinkExternalBigquery             IntegrationType = "flink_external_bigquery"
	IntegrationTypeFlinkExternalKafka                IntegrationType = "flink_external_kafka"
	IntegrationTypeFlinkExternalPostgresql           IntegrationType = "flink_external_postgresql"
	IntegrationTypeInternalConnectivity              IntegrationType = "internal_connectivity"
	IntegrationTypeJolokia                           IntegrationType = "jolokia"
	IntegrationTypeKafkaConnect                      IntegrationType = "kafka_connect"
	IntegrationTypeKafkaConnectPostgresql            IntegrationType = "kafka_connect_postgresql"
	IntegrationTypeKafkaLogs                         IntegrationType = "kafka_logs"
	IntegrationTypeKafkaMirrormaker                  IntegrationType = "kafka_mirrormaker"
	IntegrationTypeLogs                              IntegrationType = "logs"
	IntegrationTypeM3Aggregator                      IntegrationType = "m3aggregator"
	IntegrationTypeM3Coordinator                     IntegrationType = "m3coordinator"
	IntegrationTypeMetrics                           IntegrationType = "metrics"
	IntegrationTypeOpensearchCrossClusterReplication IntegrationType = "opensearch_cross_cluster_replication"
	IntegrationTypeOpensearchCrossClusterSearch      IntegrationType = "opensearch_cross_cluster_search"
	IntegrationTypePrometheus                        IntegrationType = "prometheus"
	IntegrationTypeReadReplica                       IntegrationType = "read_replica"
	IntegrationTypeRsyslog                           IntegrationType = "rsyslog"
	IntegrationTypeSchemaRegistryProxy               IntegrationType = "schema_registry_proxy"
	IntegrationTypeStresstester                      IntegrationType = "stresstester"
	IntegrationTypeThanosMigrate                     IntegrationType = "thanos_migrate"
	IntegrationTypeThanoscompactor                   IntegrationType = "thanoscompactor"
	IntegrationTypeThanosquery                       IntegrationType = "thanosquery"
	IntegrationTypeThanosstore                       IntegrationType = "thanosstore"
	IntegrationTypeVector                            IntegrationType = "vector"
	IntegrationTypeVmalert                           IntegrationType = "vmalert"
)

func IntegrationTypeChoices() []string {
	return []string{"alertmanager", "autoscaler", "caching", "cassandra_cross_service_cluster", "clickhouse_credentials", "clickhouse_kafka", "clickhouse_postgresql", "dashboard", "datadog", "datasource", "external_aws_cloudwatch_logs", "external_aws_cloudwatch_metrics", "external_elasticsearch_logs", "external_google_cloud_logging", "external_opensearch_logs", "flink", "flink_external_bigquery", "flink_external_kafka", "flink_external_postgresql", "internal_connectivity", "jolokia", "kafka_connect", "kafka_connect_postgresql", "kafka_logs", "kafka_mirrormaker", "logs", "m3aggregator", "m3coordinator", "metrics", "opensearch_cross_cluster_replication", "opensearch_cross_cluster_search", "prometheus", "read_replica", "rsyslog", "schema_registry_proxy", "stresstester", "thanos_migrate", "thanoscompactor", "thanosquery", "thanosstore", "vector", "vmalert"}
}

type KafkaAuthenticationMethodType string

const (
	KafkaAuthenticationMethodTypeCertificate KafkaAuthenticationMethodType = "certificate"
	KafkaAuthenticationMethodTypeSasl        KafkaAuthenticationMethodType = "sasl"
)

func KafkaAuthenticationMethodTypeChoices() []string {
	return []string{"certificate", "sasl"}
}

// KafkaConnectOut Service type information
type KafkaConnectOut struct {
	DefaultVersion         *string          `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string           `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string          `json:"latest_available_version,omitempty"` // Latest available version of the service
	ServicePlans           []ServicePlanOut `json:"service_plans"`                      // List of plans available for this type of service
	UserConfigSchema       map[string]any   `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}

// KafkaMirrormakerOut Service type information
type KafkaMirrormakerOut struct {
	DefaultVersion         *string          `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string           `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string          `json:"latest_available_version,omitempty"` // Latest available version of the service
	ServicePlans           []ServicePlanOut `json:"service_plans"`                      // List of plans available for this type of service
	UserConfigSchema       map[string]any   `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}

// KafkaOut Service type information
type KafkaOut struct {
	DefaultVersion         *string          `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string           `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string          `json:"latest_available_version,omitempty"` // Latest available version of the service
	ServicePlans           []ServicePlanOut `json:"service_plans"`                      // List of plans available for this type of service
	UserConfigSchema       map[string]any   `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}
type KafkaSslCaType string

const (
	KafkaSslCaTypeProjectCa   KafkaSslCaType = "project_ca"
	KafkaSslCaTypeLetsencrypt KafkaSslCaType = "letsencrypt"
)

func KafkaSslCaTypeChoices() []string {
	return []string{"project_ca", "letsencrypt"}
}

type LevelType string

const (
	LevelTypeNotice  LevelType = "notice"
	LevelTypeWarning LevelType = "warning"
)

func LevelTypeChoices() []string {
	return []string{"notice", "warning"}
}

type LikelyErrorCauseType string

const (
	LikelyErrorCauseTypeNull        LikelyErrorCauseType = "null"
	LikelyErrorCauseTypeDestination LikelyErrorCauseType = "destination"
	LikelyErrorCauseTypeIntegration LikelyErrorCauseType = "integration"
	LikelyErrorCauseTypeSource      LikelyErrorCauseType = "source"
	LikelyErrorCauseTypeUnknown     LikelyErrorCauseType = "unknown"
)

func LikelyErrorCauseTypeChoices() []string {
	return []string{"null", "destination", "integration", "source", "unknown"}
}

// ListProjectServiceTypesOut Service plans by service type
type ListProjectServiceTypesOut struct {
	Cassandra        *CassandraOut        `json:"cassandra,omitempty"`         // Service type information
	Clickhouse       *ClickhouseOut       `json:"clickhouse,omitempty"`        // Service type information
	Dragonfly        *DragonflyOut        `json:"dragonfly,omitempty"`         // Service type information
	Elasticsearch    *ElasticsearchOut    `json:"elasticsearch,omitempty"`     // Service type information
	Flink            *FlinkOut            `json:"flink,omitempty"`             // Service type information
	Grafana          *GrafanaOut          `json:"grafana,omitempty"`           // Service type information
	Influxdb         *InfluxdbOut         `json:"influxdb,omitempty"`          // Service type information
	Kafka            *KafkaOut            `json:"kafka,omitempty"`             // Service type information
	KafkaConnect     *KafkaConnectOut     `json:"kafka_connect,omitempty"`     // Service type information
	KafkaMirrormaker *KafkaMirrormakerOut `json:"kafka_mirrormaker,omitempty"` // Service type information
	M3Aggregator     *AggregatorOut       `json:"m3aggregator,omitempty"`      // Service type information
	M3Db             *DbOut               `json:"m3db,omitempty"`              // Service type information
	Mysql            *MysqlOut            `json:"mysql,omitempty"`             // Service type information
	Opensearch       *OpensearchOut       `json:"opensearch,omitempty"`        // Service type information
	Pg               *PgOut               `json:"pg,omitempty"`                // Service type information
	Redis            *RedisOut            `json:"redis,omitempty"`             // Service type information
	Valkey           *ValkeyOut           `json:"valkey,omitempty"`            // Service type information
}

// ListPublicServiceTypesOut Service plans by service type
type ListPublicServiceTypesOut struct {
	Cassandra        *CassandraOut        `json:"cassandra,omitempty"`         // Service type information
	Clickhouse       *ClickhouseOut       `json:"clickhouse,omitempty"`        // Service type information
	Dragonfly        *DragonflyOut        `json:"dragonfly,omitempty"`         // Service type information
	Elasticsearch    *ElasticsearchOut    `json:"elasticsearch,omitempty"`     // Service type information
	Flink            *FlinkOut            `json:"flink,omitempty"`             // Service type information
	Grafana          *GrafanaOut          `json:"grafana,omitempty"`           // Service type information
	Influxdb         *InfluxdbOut         `json:"influxdb,omitempty"`          // Service type information
	Kafka            *KafkaOut            `json:"kafka,omitempty"`             // Service type information
	KafkaConnect     *KafkaConnectOut     `json:"kafka_connect,omitempty"`     // Service type information
	KafkaMirrormaker *KafkaMirrormakerOut `json:"kafka_mirrormaker,omitempty"` // Service type information
	M3Aggregator     *AggregatorOut       `json:"m3aggregator,omitempty"`      // Service type information
	M3Db             *DbOut               `json:"m3db,omitempty"`              // Service type information
	Mysql            *MysqlOut            `json:"mysql,omitempty"`             // Service type information
	Opensearch       *OpensearchOut       `json:"opensearch,omitempty"`        // Service type information
	Pg               *PgOut               `json:"pg,omitempty"`                // Service type information
	Redis            *RedisOut            `json:"redis,omitempty"`             // Service type information
	Valkey           *ValkeyOut           `json:"valkey,omitempty"`            // Service type information
}
type LogOut struct {
	Msg  string  `json:"msg"`            // Log message
	Time *string `json:"time,omitempty"` // Timestamp in ISO 8601 format, always in UTC
	Unit *string `json:"unit,omitempty"` // SystemD unit name
}

// MaintenanceIn Automatic maintenance settings
type MaintenanceIn struct {
	Dow  DowType `json:"dow,omitempty"`  // Day of week for installing updates
	Time *string `json:"time,omitempty"` // Time for installing updates, UTC
}

// MaintenanceOut Automatic maintenance settings
type MaintenanceOut struct {
	Dow     DowTypeAlt  `json:"dow"`     // Day of week for installing updates
	Time    string      `json:"time"`    // Time for installing updates, UTC
	Updates []UpdateOut `json:"updates"` // List of updates waiting to be installed
}
type MasterLinkStatusType string

const (
	MasterLinkStatusTypeUp   MasterLinkStatusType = "up"
	MasterLinkStatusTypeDown MasterLinkStatusType = "down"
)

func MasterLinkStatusTypeChoices() []string {
	return []string{"up", "down"}
}

// MetadataOut Notification metadata
type MetadataOut struct {
	EndOfLifeHelpArticleUrl *string    `json:"end_of_life_help_article_url,omitempty"` // Link to the help article
	EndOfLifePolicyUrl      *string    `json:"end_of_life_policy_url,omitempty"`       // Link to the help article
	ServiceEndOfLifeTime    *time.Time `json:"service_end_of_life_time,omitempty"`     // Timestamp in ISO 8601 format, always in UTC
	UpgradeToServiceType    *string    `json:"upgrade_to_service_type,omitempty"`      // If the customer takes no action, the service is updated to this service type when end of life is reached on the Aiven platform. If it is the same as the service type, the platform only upgrades the version.
	UpgradeToVersion        *string    `json:"upgrade_to_version,omitempty"`           // The version to which the service will be updated at the end of life on the Aiven platform if the user does not take any action
}
type MethodType string

const (
	MethodTypeDump        MethodType = "dump"
	MethodTypeMysqldump   MethodType = "mysqldump"
	MethodTypePgDump      MethodType = "pg_dump"
	MethodTypeReplication MethodType = "replication"
	MethodTypeScan        MethodType = "scan"
)

func MethodTypeChoices() []string {
	return []string{"dump", "mysqldump", "pg_dump", "replication", "scan"}
}

type MethodTypeAlt string

const (
	MethodTypeAltDump        MethodTypeAlt = "dump"
	MethodTypeAltReplication MethodTypeAlt = "replication"
)

func MethodTypeAltChoices() []string {
	return []string{"dump", "replication"}
}

// MigrationCheckIn Payload to be used with migration_check
type MigrationCheckIn struct {
	IgnoreDbs         *string       `json:"ignore_dbs,omitempty"`          // Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment)
	Method            MethodTypeAlt `json:"method,omitempty"`              // The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types)
	SourceProjectName *string       `json:"source_project_name,omitempty"` // Project name
	SourceServiceName *string       `json:"source_service_name,omitempty"` // Service name
	SourceServiceUri  *string       `json:"source_service_uri,omitempty"`  // Service URI of the source MySQL or PostgreSQL database with admin credentials. Used with migration_check.
}
type MigrationDetailOut struct {
	Dbname string                    `json:"dbname"`          // Migrated db name (PG, MySQL) or number (Redis, Dragonfly)
	Error  *string                   `json:"error,omitempty"` // Error message in case that migration has failed
	Method MethodType                `json:"method"`          // The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types)
	Status MigrationDetailStatusType `json:"status"`          // Migration status
}
type MigrationDetailStatusType string

const (
	MigrationDetailStatusTypeDone    MigrationDetailStatusType = "done"
	MigrationDetailStatusTypeFailed  MigrationDetailStatusType = "failed"
	MigrationDetailStatusTypeRunning MigrationDetailStatusType = "running"
	MigrationDetailStatusTypeSyncing MigrationDetailStatusType = "syncing"
)

func MigrationDetailStatusTypeChoices() []string {
	return []string{"done", "failed", "running", "syncing"}
}

// MigrationOut Service migration info
type MigrationOut struct {
	Error                  *string              `json:"error,omitempty"`                      // Error message in case that migration has failed
	MasterLastIoSecondsAgo *int                 `json:"master_last_io_seconds_ago,omitempty"` // Redis only: how many seconds since last I/O with redis master
	MasterLinkStatus       MasterLinkStatusType `json:"master_link_status,omitempty"`         // Redis only: replication master link status
	Method                 MethodType           `json:"method"`                               // The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types)
	Status                 MigrationStatusType  `json:"status"`                               // Migration status
}
type MigrationStatusType string

const (
	MigrationStatusTypeDone    MigrationStatusType = "done"
	MigrationStatusTypeFailed  MigrationStatusType = "failed"
	MigrationStatusTypeRunning MigrationStatusType = "running"
	MigrationStatusTypeSyncing MigrationStatusType = "syncing"
)

func MigrationStatusTypeChoices() []string {
	return []string{"done", "failed", "running", "syncing"}
}

// MysqlOut Service type information
type MysqlOut struct {
	DefaultVersion         *string          `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string           `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string          `json:"latest_available_version,omitempty"` // Latest available version of the service
	ServicePlans           []ServicePlanOut `json:"service_plans"`                      // List of plans available for this type of service
	UserConfigSchema       map[string]any   `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}
type NodeStateOut struct {
	Name            string              `json:"name"`                       // Name of the service node
	ProgressUpdates []ProgressUpdateOut `json:"progress_updates,omitempty"` // Extra information regarding the progress for current state
	Role            RoleType            `json:"role,omitempty"`             // Role of this node. Only returned for a subset of service types
	Shard           *ShardOut           `json:"shard,omitempty"`            // Shard of this node. Only returned for a subset of service types
	State           NodeStateType       `json:"state"`                      // Current state of the service node
}
type NodeStateType string

const (
	NodeStateTypeLeaving     NodeStateType = "leaving"
	NodeStateTypeRunning     NodeStateType = "running"
	NodeStateTypeSettingUpVm NodeStateType = "setting_up_vm"
	NodeStateTypeSyncingData NodeStateType = "syncing_data"
	NodeStateTypeTimingOut   NodeStateType = "timing_out"
	NodeStateTypeUnknown     NodeStateType = "unknown"
)

func NodeStateTypeChoices() []string {
	return []string{"leaving", "running", "setting_up_vm", "syncing_data", "timing_out", "unknown"}
}

// OpensearchOut Service type information
type OpensearchOut struct {
	DefaultVersion         *string          `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string           `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string          `json:"latest_available_version,omitempty"` // Latest available version of the service
	ServicePlans           []ServicePlanOut `json:"service_plans"`                      // List of plans available for this type of service
	UserConfigSchema       map[string]any   `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}
type PeriodType string

const (
	PeriodTypeHour  PeriodType = "hour"
	PeriodTypeDay   PeriodType = "day"
	PeriodTypeWeek  PeriodType = "week"
	PeriodTypeMonth PeriodType = "month"
	PeriodTypeYear  PeriodType = "year"
)

func PeriodTypeChoices() []string {
	return []string{"hour", "day", "week", "month", "year"}
}

type PermissionType string

const (
	PermissionTypeAdmin     PermissionType = "admin"
	PermissionTypeRead      PermissionType = "read"
	PermissionTypeReadwrite PermissionType = "readwrite"
	PermissionTypeWrite     PermissionType = "write"
)

func PermissionTypeChoices() []string {
	return []string{"admin", "read", "readwrite", "write"}
}

type PermissionTypeAlt string

const (
	PermissionTypeAltSchemaRegistryRead  PermissionTypeAlt = "schema_registry_read"
	PermissionTypeAltSchemaRegistryWrite PermissionTypeAlt = "schema_registry_write"
)

func PermissionTypeAltChoices() []string {
	return []string{"schema_registry_read", "schema_registry_write"}
}

// PgOut Service type information
type PgOut struct {
	DefaultVersion         *string          `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string           `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string          `json:"latest_available_version,omitempty"` // Latest available version of the service
	ServicePlans           []ServicePlanOut `json:"service_plans"`                      // List of plans available for this type of service
	UserConfigSchema       map[string]any   `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}
type PhaseType string

const (
	PhaseTypePrepare    PhaseType = "prepare"
	PhaseTypeBasebackup PhaseType = "basebackup"
	PhaseTypeStream     PhaseType = "stream"
	PhaseTypeFinalize   PhaseType = "finalize"
)

func PhaseTypeChoices() []string {
	return []string{"prepare", "basebackup", "stream", "finalize"}
}

type PoolModeType string

const (
	PoolModeTypeSession     PoolModeType = "session"
	PoolModeTypeTransaction PoolModeType = "transaction"
	PoolModeTypeStatement   PoolModeType = "statement"
)

func PoolModeTypeChoices() []string {
	return []string{"session", "transaction", "statement"}
}

type ProgressUpdateOut struct {
	Completed bool      `json:"completed"`         // Indicates whether this phase has been completed or not
	Current   *int      `json:"current,omitempty"` // Current progress for this phase. May be missing or null.
	Max       *int      `json:"max,omitempty"`     // Maximum progress value for this phase. May be missing or null. May change.
	Min       *int      `json:"min,omitempty"`     // Minimum progress value for this phase. May be missing or null.
	Phase     PhaseType `json:"phase"`             // Key identifying this phase
	Unit      UnitType  `json:"unit,omitempty"`    // Unit for current/min/max values. New units may be added. If null should be treated as generic unit
}

// ProjectGetServiceLogsIn ProjectGetServiceLogsRequestBody
type ProjectGetServiceLogsIn struct {
	Limit     *int          `json:"limit,omitempty"`      // How many log entries to receive at most
	Offset    *string       `json:"offset,omitempty"`     // Opaque offset identifier
	SortOrder SortOrderType `json:"sort_order,omitempty"` // Sort order for log messages
}

// ProjectGetServiceLogsOut ProjectGetServiceLogsResponse
type ProjectGetServiceLogsOut struct {
	FirstLogOffset string   `json:"first_log_offset"` // Opaque offset identifier of the first received log message. A null value is returned when there are no logs at all.
	Logs           []LogOut `json:"logs"`             // List of log entries
	Offset         string   `json:"offset"`           // Opaque offset identifier. A null value is returned when there are no logs at all.
}

// ProjectServiceTagsReplaceIn ProjectServiceTagsReplaceRequestBody
type ProjectServiceTagsReplaceIn struct {
	Tags map[string]string `json:"tags"` // Set of resource tags
}

// ProjectServiceTagsUpdateIn ProjectServiceTagsUpdateRequestBody
type ProjectServiceTagsUpdateIn struct {
	Tags map[string]string `json:"tags"` // Set of resource tags
}
type QueryOut struct {
	ActiveChannelSubscriptions                *int     `json:"active_channel_subscriptions,omitempty"`                  // Currently active channel subscriptions
	ActiveDatabase                            *string  `json:"active_database,omitempty"`                               // Selected database
	ActivePatternMatchingChannelSubscriptions *int     `json:"active_pattern_matching_channel_subscriptions,omitempty"` // Currently active channel subscriptions using pattern matching
	ApplicationName                           *string  `json:"application_name,omitempty"`                              // Application name when set
	BackendStart                              *string  `json:"backend_start,omitempty"`                                 // Timestamp in ISO 8601 format, always in UTC
	BackendType                               *string  `json:"backend_type,omitempty"`                                  // Backend type
	BackendXid                                *int     `json:"backend_xid,omitempty"`                                   // XID for current backend
	BackendXmin                               *int     `json:"backend_xmin,omitempty"`                                  // xmin for current backend
	ClientAddr                                *string  `json:"client_addr,omitempty"`                                   // IP address:port pair. Not always available due to load balancers
	ClientHostname                            *string  `json:"client_hostname,omitempty"`                               // Client hostname
	ClientPort                                *int     `json:"client_port,omitempty"`                                   // Client port, -1 is unknown
	ConnectionAgeSeconds                      *float64 `json:"connection_age_seconds,omitempty"`                        // Connection age in seconds
	ConnectionIdleSeconds                     *float64 `json:"connection_idle_seconds,omitempty"`                       // Connection idle time in seconds
	Datid                                     *int     `json:"datid,omitempty"`                                         // Database ID
	Datname                                   *string  `json:"datname,omitempty"`                                       // Database name
	Flags                                     []string `json:"flags,omitempty"`                                         // Connection state flags
	FlagsRaw                                  *string  `json:"flags_raw,omitempty"`                                     // Raw connection flags string
	Id                                        *string  `json:"id,omitempty"`                                            // Unique connection ID
	LeaderPid                                 *int     `json:"leader_pid,omitempty"`                                    // Leader process ID
	MultiExecCommands                         *int     `json:"multi_exec_commands,omitempty"`                           // Number of MULTI/EXEC comands
	Name                                      *string  `json:"name,omitempty"`                                          // Connection name, if specified
	OutputBuffer                              *int     `json:"output_buffer,omitempty"`                                 // Output buffer length (disabled if 0)
	OutputBufferMemory                        *int     `json:"output_buffer_memory,omitempty"`                          // Output buffer memory
	OutputListLength                          *int     `json:"output_list_length,omitempty"`                            // Output list, overflow for output buffering
	Pid                                       *int     `json:"pid,omitempty"`                                           // Connection process ID
	Query                                     *string  `json:"query,omitempty"`                                         // Last/current query running on this connection
	QueryBuffer                               *int     `json:"query_buffer,omitempty"`                                  // Query buffer length (disabled if 0)
	QueryBufferFree                           *int     `json:"query_buffer_free,omitempty"`                             // Free bytes in query buffer, if enabled
	QueryDuration                             *float64 `json:"query_duration,omitempty"`                                // Duration of the last/current query in seconds
	QueryId                                   *int     `json:"query_id,omitempty"`                                      // Hash code to identify identical normalized queries.
	QueryStart                                *string  `json:"query_start,omitempty"`                                   // Timestamp in ISO 8601 format, always in UTC
	State                                     *string  `json:"state,omitempty"`                                         // Connection state
	StateChange                               *string  `json:"state_change,omitempty"`                                  // Timestamp in ISO 8601 format, always in UTC
	Usename                                   *string  `json:"usename,omitempty"`                                       // Username
	Usesysid                                  *int     `json:"usesysid,omitempty"`                                      // User ID
	WaitEvent                                 *string  `json:"wait_event,omitempty"`                                    // Connection wait event
	WaitEventType                             *string  `json:"wait_event_type,omitempty"`                               // Connection wait event type
	Waiting                                   *bool    `json:"waiting,omitempty"`                                       // Query is waiting
	XactStart                                 *string  `json:"xact_start,omitempty"`                                    // Timestamp in ISO 8601 format, always in UTC
}
type RecoveryModeType string

const (
	RecoveryModeTypeBasic RecoveryModeType = "basic"
	RecoveryModeTypePitr  RecoveryModeType = "pitr"
)

func RecoveryModeTypeChoices() []string {
	return []string{"basic", "pitr"}
}

// RedisOut Service type information
type RedisOut struct {
	DefaultVersion         *string          `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string           `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string          `json:"latest_available_version,omitempty"` // Latest available version of the service
	ServicePlans           []ServicePlanOut `json:"service_plans"`                      // List of plans available for this type of service
	UserConfigSchema       map[string]any   `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}
type ResultCodeOut struct {
	Code   string  `json:"code"`             // Machine-readable key code, which represents the result of the task
	Dbname *string `json:"dbname,omitempty"` // Database which related to the result code
}
type RoleType string

const (
	RoleTypeMaster      RoleType = "master"
	RoleTypeStandby     RoleType = "standby"
	RoleTypeReadReplica RoleType = "read-replica"
)

func RoleTypeChoices() []string {
	return []string{"master", "standby", "read-replica"}
}

type RouteType string

const (
	RouteTypeDynamic     RouteType = "dynamic"
	RouteTypePublic      RouteType = "public"
	RouteTypePrivate     RouteType = "private"
	RouteTypePrivatelink RouteType = "privatelink"
)

func RouteTypeChoices() []string {
	return []string{"dynamic", "public", "private", "privatelink"}
}

type SchemaRegistryAclOut struct {
	Id         *string           `json:"id,omitempty"` // ID
	Permission PermissionTypeAlt `json:"permission"`   // ACL entry for Schema Registry
	Resource   string            `json:"resource"`     // Schema Registry ACL entry resource name pattern
	Username   string            `json:"username"`
}

// ServiceBackupToAnotherRegionReportIn ServiceBackupToAnotherRegionReportRequestBody
type ServiceBackupToAnotherRegionReportIn struct {
	Period PeriodType `json:"period,omitempty"` // Metrics time period
}

// ServiceCancelQueryIn ServiceCancelQueryRequestBody
type ServiceCancelQueryIn struct {
	Pid       *int  `json:"pid,omitempty"`       // Database server connection ID
	Terminate *bool `json:"terminate,omitempty"` // Request immediate termination instead of soft cancel
}

// ServiceCreateIn ServiceCreateRequestBody
type ServiceCreateIn struct {
	Cloud                 *string                 `json:"cloud,omitempty"`                  // Target cloud
	CopyTags              *bool                   `json:"copy_tags,omitempty"`              // If this is a forked service, copy tags from the source service. If request contains additional tags, the tags copied from source are updated with them.
	DiskSpaceMb           *float64                `json:"disk_space_mb,omitempty"`          // Megabytes of disk space for data storage
	GroupName             *string                 `json:"group_name,omitempty"`             // Service group name (DEPRECATED: do not use)
	Maintenance           *MaintenanceIn          `json:"maintenance,omitempty"`            // Automatic maintenance settings
	Plan                  string                  `json:"plan"`                             // Subscription plan
	ProjectVpcId          *string                 `json:"project_vpc_id,omitempty"`         // Project VPC ID
	ServiceIntegrations   *[]ServiceIntegrationIn `json:"service_integrations,omitempty"`   // Service integrations to enable for the service. Some integration types affect how a service is created and they must be provided as part of the creation call instead of being defined later.
	ServiceName           string                  `json:"service_name"`                     // Service name
	ServiceType           string                  `json:"service_type"`                     // Service type code
	StaticIps             *[]string               `json:"static_ips,omitempty"`             // Static IP addresses to associate with the service
	Tags                  *map[string]string      `json:"tags,omitempty"`                   // Set of resource tags
	TechEmails            *[]TechEmailIn          `json:"tech_emails,omitempty"`            // List of service technical email addresses
	TerminationProtection *bool                   `json:"termination_protection,omitempty"` // Service is protected against termination and powering off
	UserConfig            *map[string]any         `json:"user_config,omitempty"`            // Service type-specific settings
}

// ServiceCreateOut Service information
type ServiceCreateOut struct {
	Acl                    []AclOut                 `json:"acl,omitempty"`                      // List of Kafka ACL entries
	Backups                []BackupOut              `json:"backups,omitempty"`                  // List of backups for the service
	CloudDescription       *string                  `json:"cloud_description,omitempty"`        // Cloud provider and location
	CloudName              string                   `json:"cloud_name"`                         // Target cloud
	Components             []ComponentOut           `json:"components,omitempty"`               // Service component information objects
	ConnectionInfo         map[string]any           `json:"connection_info,omitempty"`          // Service-specific connection information properties
	ConnectionPools        []ConnectionPoolOut      `json:"connection_pools,omitempty"`         // PostgreSQL PGBouncer connection pools
	CreateTime             time.Time                `json:"create_time"`                        // Service creation timestamp (ISO 8601)
	Databases              []string                 `json:"databases,omitempty"`                // List of service's user database names
	DiskSpaceMb            *float64                 `json:"disk_space_mb,omitempty"`            // Megabytes of disk space for data storage
	Features               map[string]any           `json:"features,omitempty"`                 // Feature flags
	GroupList              []string                 `json:"group_list"`                         // List of service groups the service belongs to. This field is deprecated. It is always set to single element with value 'default'
	Maintenance            *MaintenanceOut          `json:"maintenance,omitempty"`              // Automatic maintenance settings
	Metadata               map[string]any           `json:"metadata,omitempty"`                 // Service type specific metadata
	NodeCount              *int                     `json:"node_count,omitempty"`               // Number of service nodes in the active plan
	NodeCpuCount           *int                     `json:"node_cpu_count,omitempty"`           // Number of CPUs for each node
	NodeMemoryMb           *float64                 `json:"node_memory_mb,omitempty"`           // Megabytes of memory for each node
	NodeStates             []NodeStateOut           `json:"node_states,omitempty"`              // State of individual service nodes
	Plan                   string                   `json:"plan"`                               // Subscription plan
	ProjectVpcId           string                   `json:"project_vpc_id"`                     // Project VPC ID
	SchemaRegistryAcl      []SchemaRegistryAclOut   `json:"schema_registry_acl,omitempty"`      // List of Schema Registry ACL entries
	ServiceIntegrations    []ServiceIntegrationOut  `json:"service_integrations"`               // Integrations with other services
	ServiceName            string                   `json:"service_name"`                       // Service name
	ServiceNotifications   []ServiceNotificationOut `json:"service_notifications,omitempty"`    // Service notifications
	ServiceType            string                   `json:"service_type"`                       // Service type code
	ServiceTypeDescription *string                  `json:"service_type_description,omitempty"` // Single line description of the service
	ServiceUri             string                   `json:"service_uri"`                        // URI for connecting to the service (may be null)
	ServiceUriParams       map[string]any           `json:"service_uri_params,omitempty"`       // service_uri parameterized into key-value pairs
	State                  ServiceStateType         `json:"state"`                              // State of the service
	Tags                   map[string]string        `json:"tags,omitempty"`                     // Set of resource tags
	TechEmails             []TechEmailOut           `json:"tech_emails,omitempty"`              // List of service technical email addresses
	TerminationProtection  bool                     `json:"termination_protection"`             // Service is protected against termination and powering off
	Topics                 []TopicOut               `json:"topics,omitempty"`                   // Kafka topics. DEPRECATED: Use /project/$project/service/$service/topic instead
	UpdateTime             time.Time                `json:"update_time"`                        // Service last update timestamp (ISO 8601)
	UserConfig             map[string]any           `json:"user_config"`                        // Service type-specific settings
	Users                  []UserOut                `json:"users,omitempty"`                    // List of service users
}

// ServiceDatabaseCreateIn ServiceDatabaseCreateRequestBody
type ServiceDatabaseCreateIn struct {
	Database  string  `json:"database"`             // Service database name
	LcCollate *string `json:"lc_collate,omitempty"` // Default string sort order (LC_COLLATE) for PostgreSQL database
	LcCtype   *string `json:"lc_ctype,omitempty"`   // Default character classification (LC_CTYPE) for PostgreSQL database
}

// ServiceGetMigrationStatusOut ServiceGetMigrationStatusResponse
type ServiceGetMigrationStatusOut struct {
	Migration       MigrationOut         `json:"migration"`                  // Service migration info
	MigrationDetail []MigrationDetailOut `json:"migration_detail,omitempty"` // Migration status per database
}

// ServiceGetOut Service information
type ServiceGetOut struct {
	Acl                    []AclOut                 `json:"acl,omitempty"`                      // List of Kafka ACL entries
	Backups                []BackupOut              `json:"backups,omitempty"`                  // List of backups for the service
	CloudDescription       *string                  `json:"cloud_description,omitempty"`        // Cloud provider and location
	CloudName              string                   `json:"cloud_name"`                         // Target cloud
	Components             []ComponentOut           `json:"components,omitempty"`               // Service component information objects
	ConnectionInfo         map[string]any           `json:"connection_info,omitempty"`          // Service-specific connection information properties
	ConnectionPools        []ConnectionPoolOut      `json:"connection_pools,omitempty"`         // PostgreSQL PGBouncer connection pools
	CreateTime             time.Time                `json:"create_time"`                        // Service creation timestamp (ISO 8601)
	Databases              []string                 `json:"databases,omitempty"`                // List of service's user database names
	DiskSpaceMb            *float64                 `json:"disk_space_mb,omitempty"`            // Megabytes of disk space for data storage
	Features               map[string]any           `json:"features,omitempty"`                 // Feature flags
	GroupList              []string                 `json:"group_list"`                         // List of service groups the service belongs to. This field is deprecated. It is always set to single element with value 'default'
	Maintenance            *MaintenanceOut          `json:"maintenance,omitempty"`              // Automatic maintenance settings
	Metadata               map[string]any           `json:"metadata,omitempty"`                 // Service type specific metadata
	NodeCount              *int                     `json:"node_count,omitempty"`               // Number of service nodes in the active plan
	NodeCpuCount           *int                     `json:"node_cpu_count,omitempty"`           // Number of CPUs for each node
	NodeMemoryMb           *float64                 `json:"node_memory_mb,omitempty"`           // Megabytes of memory for each node
	NodeStates             []NodeStateOut           `json:"node_states,omitempty"`              // State of individual service nodes
	Plan                   string                   `json:"plan"`                               // Subscription plan
	ProjectVpcId           string                   `json:"project_vpc_id"`                     // Project VPC ID
	SchemaRegistryAcl      []SchemaRegistryAclOut   `json:"schema_registry_acl,omitempty"`      // List of Schema Registry ACL entries
	ServiceIntegrations    []ServiceIntegrationOut  `json:"service_integrations"`               // Integrations with other services
	ServiceName            string                   `json:"service_name"`                       // Service name
	ServiceNotifications   []ServiceNotificationOut `json:"service_notifications,omitempty"`    // Service notifications
	ServiceType            string                   `json:"service_type"`                       // Service type code
	ServiceTypeDescription *string                  `json:"service_type_description,omitempty"` // Single line description of the service
	ServiceUri             string                   `json:"service_uri"`                        // URI for connecting to the service (may be null)
	ServiceUriParams       map[string]any           `json:"service_uri_params,omitempty"`       // service_uri parameterized into key-value pairs
	State                  ServiceStateType         `json:"state"`                              // State of the service
	Tags                   map[string]string        `json:"tags,omitempty"`                     // Set of resource tags
	TechEmails             []TechEmailOut           `json:"tech_emails,omitempty"`              // List of service technical email addresses
	TerminationProtection  bool                     `json:"termination_protection"`             // Service is protected against termination and powering off
	Topics                 []TopicOut               `json:"topics,omitempty"`                   // Kafka topics. DEPRECATED: Use /project/$project/service/$service/topic instead
	UpdateTime             time.Time                `json:"update_time"`                        // Service last update timestamp (ISO 8601)
	UserConfig             map[string]any           `json:"user_config"`                        // Service type-specific settings
	Users                  []UserOut                `json:"users,omitempty"`                    // List of service users
}
type ServiceIntegrationIn struct {
	DestEndpointId   *string         `json:"dest_endpoint_id,omitempty"`   // Integration destination endpoint ID
	DestProject      *string         `json:"dest_project,omitempty"`       // Destination project name
	DestService      *string         `json:"dest_service,omitempty"`       // Destination service name
	IntegrationType  IntegrationType `json:"integration_type"`             // Service integration type
	SourceEndpointId *string         `json:"source_endpoint_id,omitempty"` // Integration source endpoint ID
	SourceProject    *string         `json:"source_project,omitempty"`     // Source project name
	SourceService    *string         `json:"source_service,omitempty"`     // Source service name
	UserConfig       *map[string]any `json:"user_config,omitempty"`        // Service type-specific settings
}
type ServiceIntegrationOut struct {
	Active               bool                  `json:"active"`                       // True when integration is active
	Description          string                `json:"description"`                  // Description of the integration
	DestEndpoint         *string               `json:"dest_endpoint,omitempty"`      // Destination endpoint name
	DestEndpointId       *string               `json:"dest_endpoint_id,omitempty"`   // Destination endpoint id
	DestProject          string                `json:"dest_project"`                 // Project name
	DestService          *string               `json:"dest_service,omitempty"`       // Destination service name
	DestServiceType      string                `json:"dest_service_type"`            // Service type code
	Enabled              bool                  `json:"enabled"`                      // True when integration is enabled
	IntegrationStatus    *IntegrationStatusOut `json:"integration_status,omitempty"` // Integration status
	IntegrationType      string                `json:"integration_type"`             // Type of the integration
	ServiceIntegrationId string                `json:"service_integration_id"`       // Integration ID
	SourceEndpoint       *string               `json:"source_endpoint,omitempty"`    // Source endpoint name
	SourceEndpointId     *string               `json:"source_endpoint_id,omitempty"` // Source endpoint ID
	SourceProject        string                `json:"source_project"`               // Project name
	SourceService        string                `json:"source_service"`               // Source service name
	SourceServiceType    string                `json:"source_service_type"`          // Service type code
	UserConfig           map[string]any        `json:"user_config,omitempty"`        // Service integration settings
}

// ServiceKmsGetKeypairOut ServiceKmsGetKeypairResponse
type ServiceKmsGetKeypairOut struct {
	Certificate string `json:"certificate"` // PEM encoded certificate
	Key         string `json:"key"`         // PEM encoded private key
}

// ServiceMetricsFetchIn ServiceMetricsFetchRequestBody
type ServiceMetricsFetchIn struct {
	Period PeriodType `json:"period,omitempty"` // Metrics time period
}
type ServiceNotificationOut struct {
	Level    LevelType               `json:"level"`    // Notification level
	Message  string                  `json:"message"`  // Human notification message
	Metadata MetadataOut             `json:"metadata"` // Notification metadata
	Type     ServiceNotificationType `json:"type"`     // Notification type
}
type ServiceNotificationType string

const (
	ServiceNotificationTypeServiceEndOfLife         ServiceNotificationType = "service_end_of_life"
	ServiceNotificationTypeServicePoweredOffRemoval ServiceNotificationType = "service_powered_off_removal"
)

func ServiceNotificationTypeChoices() []string {
	return []string{"service_end_of_life", "service_powered_off_removal"}
}

type ServiceOut struct {
	Acl                    []AclOut                 `json:"acl,omitempty"`                      // List of Kafka ACL entries
	Backups                []BackupOut              `json:"backups,omitempty"`                  // List of backups for the service
	CloudDescription       *string                  `json:"cloud_description,omitempty"`        // Cloud provider and location
	CloudName              string                   `json:"cloud_name"`                         // Target cloud
	Components             []ComponentOut           `json:"components,omitempty"`               // Service component information objects
	ConnectionInfo         map[string]any           `json:"connection_info,omitempty"`          // Service-specific connection information properties
	ConnectionPools        []ConnectionPoolOut      `json:"connection_pools,omitempty"`         // PostgreSQL PGBouncer connection pools
	CreateTime             time.Time                `json:"create_time"`                        // Service creation timestamp (ISO 8601)
	Databases              []string                 `json:"databases,omitempty"`                // List of service's user database names
	DiskSpaceMb            *float64                 `json:"disk_space_mb,omitempty"`            // Megabytes of disk space for data storage
	Features               map[string]any           `json:"features,omitempty"`                 // Feature flags
	GroupList              []string                 `json:"group_list"`                         // List of service groups the service belongs to. This field is deprecated. It is always set to single element with value 'default'
	Maintenance            *MaintenanceOut          `json:"maintenance,omitempty"`              // Automatic maintenance settings
	Metadata               map[string]any           `json:"metadata,omitempty"`                 // Service type specific metadata
	NodeCount              *int                     `json:"node_count,omitempty"`               // Number of service nodes in the active plan
	NodeCpuCount           *int                     `json:"node_cpu_count,omitempty"`           // Number of CPUs for each node
	NodeMemoryMb           *float64                 `json:"node_memory_mb,omitempty"`           // Megabytes of memory for each node
	NodeStates             []NodeStateOut           `json:"node_states,omitempty"`              // State of individual service nodes
	Plan                   string                   `json:"plan"`                               // Subscription plan
	ProjectVpcId           string                   `json:"project_vpc_id"`                     // Project VPC ID
	SchemaRegistryAcl      []SchemaRegistryAclOut   `json:"schema_registry_acl,omitempty"`      // List of Schema Registry ACL entries
	ServiceIntegrations    []ServiceIntegrationOut  `json:"service_integrations"`               // Integrations with other services
	ServiceName            string                   `json:"service_name"`                       // Service name
	ServiceNotifications   []ServiceNotificationOut `json:"service_notifications,omitempty"`    // Service notifications
	ServiceType            string                   `json:"service_type"`                       // Service type code
	ServiceTypeDescription *string                  `json:"service_type_description,omitempty"` // Single line description of the service
	ServiceUri             string                   `json:"service_uri"`                        // URI for connecting to the service (may be null)
	ServiceUriParams       map[string]any           `json:"service_uri_params,omitempty"`       // service_uri parameterized into key-value pairs
	State                  ServiceStateType         `json:"state"`                              // State of the service
	Tags                   map[string]string        `json:"tags,omitempty"`                     // Set of resource tags
	TechEmails             []TechEmailOut           `json:"tech_emails,omitempty"`              // List of service technical email addresses
	TerminationProtection  bool                     `json:"termination_protection"`             // Service is protected against termination and powering off
	Topics                 []TopicOut               `json:"topics,omitempty"`                   // Kafka topics. DEPRECATED: Use /project/$project/service/$service/topic instead
	UpdateTime             time.Time                `json:"update_time"`                        // Service last update timestamp (ISO 8601)
	UserConfig             map[string]any           `json:"user_config"`                        // Service type-specific settings
	Users                  []UserOut                `json:"users,omitempty"`                    // List of service users
}
type ServicePlanOut struct {
	BackupConfig     BackupConfigOut `json:"backup_config"`                // Backup configuration for this service plan
	MaxMemoryPercent *int            `json:"max_memory_percent,omitempty"` // Maximum amount of system memory as a percentage (0-100) the service can actually use after taking into account management overhead. This is relevant for memory bound services for which some service management operations require allocating proportional amount of memory on top the basic load.
	NodeCount        *int            `json:"node_count,omitempty"`         // Number of nodes in this service plan
	Regions          map[string]any  `json:"regions,omitempty"`            // Service plan hourly price per cloud region
	ServicePlan      string          `json:"service_plan"`                 // Subscription plan
	ServiceType      string          `json:"service_type"`                 // Service type code
	ShardCount       *int            `json:"shard_count,omitempty"`        // Number of shards in this service plan
}

// ServiceQueryActivityIn ServiceQueryActivityRequestBody
type ServiceQueryActivityIn struct {
	Limit   *int    `json:"limit,omitempty"`    // Limit for number of results
	Offset  *int    `json:"offset,omitempty"`   // Offset for retrieved results based on sort order
	OrderBy *string `json:"order_by,omitempty"` // Order in which to sort retrieved results
}
type ServiceStateType string

const (
	ServiceStateTypePoweroff    ServiceStateType = "POWEROFF"
	ServiceStateTypeRebalancing ServiceStateType = "REBALANCING"
	ServiceStateTypeRebuilding  ServiceStateType = "REBUILDING"
	ServiceStateTypeRunning     ServiceStateType = "RUNNING"
)

func ServiceStateTypeChoices() []string {
	return []string{"POWEROFF", "REBALANCING", "REBUILDING", "RUNNING"}
}

// ServiceTaskCreateIn ServiceTaskCreateRequestBody
type ServiceTaskCreateIn struct {
	DatasetImport  *DatasetImportIn  `json:"dataset_import,omitempty"`  // Payload to be used with dataset_import
	MigrationCheck *MigrationCheckIn `json:"migration_check,omitempty"` // Payload to be used with migration_check
	TargetVersion  TargetVersionType `json:"target_version,omitempty"`  // Target version used with upgrade_check
	TaskType       TaskType          `json:"task_type"`                 // Service task type
}

// ServiceTaskCreateOut Task info
type ServiceTaskCreateOut struct {
	CreateTime  time.Time       `json:"create_time"`            // Timestamp in ISO 8601 format, always in UTC
	Result      string          `json:"result"`                 // Task result
	ResultCodes []ResultCodeOut `json:"result_codes,omitempty"` // List of result codes
	Success     bool            `json:"success"`                // Task success
	TaskId      string          `json:"task_id"`                // Unique identifier for the task
	TaskType    string          `json:"task_type"`              // Task type
}

// ServiceTaskGetOut Task info
type ServiceTaskGetOut struct {
	CreateTime  time.Time       `json:"create_time"`            // Timestamp in ISO 8601 format, always in UTC
	Result      string          `json:"result"`                 // Task result
	ResultCodes []ResultCodeOut `json:"result_codes,omitempty"` // List of result codes
	Success     bool            `json:"success"`                // Task success
	TaskId      string          `json:"task_id"`                // Unique identifier for the task
	TaskType    string          `json:"task_type"`              // Task type
}

// ServiceUpdateIn ServiceUpdateRequestBody
type ServiceUpdateIn struct {
	Cloud                 *string         `json:"cloud,omitempty"`                  // Target cloud
	DiskSpaceMb           *float64        `json:"disk_space_mb,omitempty"`          // Megabytes of disk space for data storage
	GroupName             *string         `json:"group_name,omitempty"`             // Service group name (DEPRECATED: do not use)
	Karapace              *bool           `json:"karapace,omitempty"`               // Switch the service to use Karapace for schema registry and REST proxy
	Maintenance           *MaintenanceIn  `json:"maintenance,omitempty"`            // Automatic maintenance settings
	Plan                  *string         `json:"plan,omitempty"`                   // Subscription plan
	Powered               *bool           `json:"powered,omitempty"`                // Power-on the service (true) or power-off (false)
	ProjectVpcId          *string         `json:"project_vpc_id,omitempty"`         // Project VPC ID
	SchemaRegistryAuthz   *bool           `json:"schema_registry_authz,omitempty"`  // Enable or disable Schema Registry authorization
	TechEmails            *[]TechEmailIn  `json:"tech_emails,omitempty"`            // List of service technical email addresses
	TerminationProtection *bool           `json:"termination_protection,omitempty"` // Service is protected against termination and powering off
	UserConfig            *map[string]any `json:"user_config,omitempty"`            // Service type-specific settings
}

// ServiceUpdateOut Service information
type ServiceUpdateOut struct {
	Acl                    []AclOut                 `json:"acl,omitempty"`                      // List of Kafka ACL entries
	Backups                []BackupOut              `json:"backups,omitempty"`                  // List of backups for the service
	CloudDescription       *string                  `json:"cloud_description,omitempty"`        // Cloud provider and location
	CloudName              string                   `json:"cloud_name"`                         // Target cloud
	Components             []ComponentOut           `json:"components,omitempty"`               // Service component information objects
	ConnectionInfo         map[string]any           `json:"connection_info,omitempty"`          // Service-specific connection information properties
	ConnectionPools        []ConnectionPoolOut      `json:"connection_pools,omitempty"`         // PostgreSQL PGBouncer connection pools
	CreateTime             time.Time                `json:"create_time"`                        // Service creation timestamp (ISO 8601)
	Databases              []string                 `json:"databases,omitempty"`                // List of service's user database names
	DiskSpaceMb            *float64                 `json:"disk_space_mb,omitempty"`            // Megabytes of disk space for data storage
	Features               map[string]any           `json:"features,omitempty"`                 // Feature flags
	GroupList              []string                 `json:"group_list"`                         // List of service groups the service belongs to. This field is deprecated. It is always set to single element with value 'default'
	Maintenance            *MaintenanceOut          `json:"maintenance,omitempty"`              // Automatic maintenance settings
	Metadata               map[string]any           `json:"metadata,omitempty"`                 // Service type specific metadata
	NodeCount              *int                     `json:"node_count,omitempty"`               // Number of service nodes in the active plan
	NodeCpuCount           *int                     `json:"node_cpu_count,omitempty"`           // Number of CPUs for each node
	NodeMemoryMb           *float64                 `json:"node_memory_mb,omitempty"`           // Megabytes of memory for each node
	NodeStates             []NodeStateOut           `json:"node_states,omitempty"`              // State of individual service nodes
	Plan                   string                   `json:"plan"`                               // Subscription plan
	ProjectVpcId           string                   `json:"project_vpc_id"`                     // Project VPC ID
	SchemaRegistryAcl      []SchemaRegistryAclOut   `json:"schema_registry_acl,omitempty"`      // List of Schema Registry ACL entries
	ServiceIntegrations    []ServiceIntegrationOut  `json:"service_integrations"`               // Integrations with other services
	ServiceName            string                   `json:"service_name"`                       // Service name
	ServiceNotifications   []ServiceNotificationOut `json:"service_notifications,omitempty"`    // Service notifications
	ServiceType            string                   `json:"service_type"`                       // Service type code
	ServiceTypeDescription *string                  `json:"service_type_description,omitempty"` // Single line description of the service
	ServiceUri             string                   `json:"service_uri"`                        // URI for connecting to the service (may be null)
	ServiceUriParams       map[string]any           `json:"service_uri_params,omitempty"`       // service_uri parameterized into key-value pairs
	State                  ServiceStateType         `json:"state"`                              // State of the service
	Tags                   map[string]string        `json:"tags,omitempty"`                     // Set of resource tags
	TechEmails             []TechEmailOut           `json:"tech_emails,omitempty"`              // List of service technical email addresses
	TerminationProtection  bool                     `json:"termination_protection"`             // Service is protected against termination and powering off
	Topics                 []TopicOut               `json:"topics,omitempty"`                   // Kafka topics. DEPRECATED: Use /project/$project/service/$service/topic instead
	UpdateTime             time.Time                `json:"update_time"`                        // Service last update timestamp (ISO 8601)
	UserConfig             map[string]any           `json:"user_config"`                        // Service type-specific settings
	Users                  []UserOut                `json:"users,omitempty"`                    // List of service users
}
type ServiceVersionOut struct {
	AivenEndOfLifeTime      *time.Time              `json:"aiven_end_of_life_time,omitempty"`       // Aiven end-of-life timestamp (ISO 8601)
	AvailabilityEndTime     *time.Time              `json:"availability_end_time,omitempty"`        // Availability end timestamp (ISO 8601)
	AvailabilityStartTime   *time.Time              `json:"availability_start_time,omitempty"`      // Availability start timestamp (ISO 8601)
	EndOfLifeHelpArticleUrl *string                 `json:"end_of_life_help_article_url,omitempty"` // Link to the help article
	MajorVersion            *string                 `json:"major_version,omitempty"`                // Service version
	ServiceType             *string                 `json:"service_type,omitempty"`                 // Service type code
	State                   ServiceVersionStateType `json:"state,omitempty"`                        // Service state
	TerminationTime         *time.Time              `json:"termination_time,omitempty"`             // Termination timestamp (ISO 8601)
	UpgradeToServiceType    *string                 `json:"upgrade_to_service_type,omitempty"`      // If the customer takes no action, the service is updated to this service type when end of life is reached on the Aiven platform. If it is the same as the service type, the platform only upgrades the version.
	UpgradeToVersion        *string                 `json:"upgrade_to_version,omitempty"`           // The version to which the service will be updated at the end of life on the Aiven platform if the user does not take any action
	UpstreamEndOfLifeTime   *time.Time              `json:"upstream_end_of_life_time,omitempty"`    // Upstream end-of-life timestamp (ISO 8601)
}
type ServiceVersionStateType string

const (
	ServiceVersionStateTypeAvailable   ServiceVersionStateType = "available"
	ServiceVersionStateTypeEol         ServiceVersionStateType = "eol"
	ServiceVersionStateTypePreview     ServiceVersionStateType = "preview"
	ServiceVersionStateTypeTerminated  ServiceVersionStateType = "terminated"
	ServiceVersionStateTypeUnavailable ServiceVersionStateType = "unavailable"
)

func ServiceVersionStateTypeChoices() []string {
	return []string{"available", "eol", "preview", "terminated", "unavailable"}
}

// ShardOut Shard of this node. Only returned for a subset of service types
type ShardOut struct {
	Name     *string `json:"name,omitempty"`     // Name of the shard.
	Position *int    `json:"position,omitempty"` // Position of this shard within the service
}
type SortOrderType string

const (
	SortOrderTypeDesc SortOrderType = "desc"
	SortOrderTypeAsc  SortOrderType = "asc"
)

func SortOrderTypeChoices() []string {
	return []string{"desc", "asc"}
}

// StateOut Service integration state
type StateOut struct {
	Errors           []string              `json:"errors"`
	LikelyErrorCause LikelyErrorCauseType  `json:"likely_error_cause,omitempty"` // Most likely cause of the errors
	Nodes            map[string]any        `json:"nodes"`
	Status           IntegrationStatusType `json:"status"` // Service integration status
}
type TargetVersionType string

const (
	TargetVersionType13 TargetVersionType = "13"
	TargetVersionType14 TargetVersionType = "14"
	TargetVersionType15 TargetVersionType = "15"
	TargetVersionType16 TargetVersionType = "16"
)

func TargetVersionTypeChoices() []string {
	return []string{"13", "14", "15", "16"}
}

type TaskType string

const (
	TaskTypeUpgradeCheck   TaskType = "upgrade_check"
	TaskTypeMigrationCheck TaskType = "migration_check"
	TaskTypeDatasetImport  TaskType = "dataset_import"
)

func TaskTypeChoices() []string {
	return []string{"upgrade_check", "migration_check", "dataset_import"}
}

type TechEmailIn struct {
	Email string `json:"email"` // User email address
}
type TechEmailOut struct {
	Email string `json:"email"` // User email address
}
type TopicOut struct {
	CleanupPolicy     string         `json:"cleanup_policy"`      // cleanup.policy
	MinInsyncReplicas int            `json:"min_insync_replicas"` // min.insync.replicas
	Partitions        int            `json:"partitions"`          // Number of partitions
	Replication       int            `json:"replication"`         // Number of replicas
	RetentionBytes    int            `json:"retention_bytes"`     // retention.bytes
	RetentionHours    int            `json:"retention_hours"`     // Retention period (hours)
	State             TopicStateType `json:"state,omitempty"`     // Topic state
	TopicName         string         `json:"topic_name"`          // Topic name
}
type TopicStateType string

const (
	TopicStateTypeActive      TopicStateType = "ACTIVE"
	TopicStateTypeConfiguring TopicStateType = "CONFIGURING"
	TopicStateTypeDeleting    TopicStateType = "DELETING"
)

func TopicStateTypeChoices() []string {
	return []string{"ACTIVE", "CONFIGURING", "DELETING"}
}

type UnitType string

const (
	UnitTypeBinlogs           UnitType = "binlogs"
	UnitTypeBytesCompressed   UnitType = "bytes_compressed"
	UnitTypeBytesUncompressed UnitType = "bytes_uncompressed"
	UnitTypeWalLsn            UnitType = "wal_lsn"
)

func UnitTypeChoices() []string {
	return []string{"binlogs", "bytes_compressed", "bytes_uncompressed", "wal_lsn"}
}

type UpdateOut struct {
	Deadline    *string    `json:"deadline,omitempty"`    // Deadline for installing the update
	Description *string    `json:"description,omitempty"` // Description of the update
	StartAfter  *string    `json:"start_after,omitempty"` // The earliest time the update will be automatically applied
	StartAt     *time.Time `json:"start_at,omitempty"`    // The time when the update will be automatically applied
}
type UsageType string

const (
	UsageTypePrimary UsageType = "primary"
	UsageTypeReplica UsageType = "replica"
)

func UsageTypeChoices() []string {
	return []string{"primary", "replica"}
}

type UserOut struct {
	AccessCert                    *string            `json:"access_cert,omitempty"`                        // Access certificate for TLS client authentication
	AccessCertNotValidAfterTime   *time.Time         `json:"access_cert_not_valid_after_time,omitempty"`   // Validity end time (ISO8601) for the current access certificate
	AccessControl                 *AccessControlOut  `json:"access_control,omitempty"`                     // Service specific access controls for user. Service type specific access control rules for user. Currently only used for configuring user ACLs for Redis version 6 and above.
	AccessKey                     *string            `json:"access_key,omitempty"`                         // Access key for TLS client authentication
	Authentication                AuthenticationType `json:"authentication,omitempty"`                     // Authentication details
	ExpiringCertNotValidAfterTime *time.Time         `json:"expiring_cert_not_valid_after_time,omitempty"` // Validity end time (ISO8601) for the expiring access certificate
	Password                      string             `json:"password"`                                     // Account password. A null value indicates a user overridden password.
	Type                          string             `json:"type"`                                         // Account type
	Username                      string             `json:"username"`                                     // Account username
}

// ValkeyOut Service type information
type ValkeyOut struct {
	DefaultVersion         *string          `json:"default_version,omitempty"`          // Default version of the service if no explicit version is defined
	Description            string           `json:"description"`                        // Single line description of the service
	LatestAvailableVersion *string          `json:"latest_available_version,omitempty"` // Latest available version of the service
	ServicePlans           []ServicePlanOut `json:"service_plans"`                      // List of plans available for this type of service
	UserConfigSchema       map[string]any   `json:"user_config_schema"`                 // JSON-Schema for the 'user_config' properties
}

// listProjectServiceTypesOut ListProjectServiceTypesResponse
type listProjectServiceTypesOut struct {
	ServiceTypes ListProjectServiceTypesOut `json:"service_types"` // Service plans by service type
}

// listPublicServiceTypesOut ListPublicServiceTypesResponse
type listPublicServiceTypesOut struct {
	ServiceTypes ListPublicServiceTypesOut `json:"service_types"` // Service plans by service type
}

// listServiceVersionsOut ListServiceVersionsResponse
type listServiceVersionsOut struct {
	ServiceVersions []ServiceVersionOut `json:"service_versions"` // Service versions
}

// projectServiceTagsListOut ProjectServiceTagsListResponse
type projectServiceTagsListOut struct {
	Tags map[string]string `json:"tags,omitempty"` // Set of resource tags
}

// serviceAlertsListOut ServiceAlertsListResponse
type serviceAlertsListOut struct {
	Alerts []AlertOut `json:"alerts"` // List of active alerts for the service
}

// serviceBackupToAnotherRegionReportOut ServiceBackupToAnotherRegionReportResponse
type serviceBackupToAnotherRegionReportOut struct {
	Metrics map[string]any `json:"metrics"` // Service metrics in Google chart compatible format
}

// serviceBackupsGetOut ServiceBackupsGetResponse
type serviceBackupsGetOut struct {
	Backups []BackupOut `json:"backups"` // List of backups for the service
}

// serviceCancelQueryOut ServiceCancelQueryResponse
type serviceCancelQueryOut struct {
	Success bool `json:"success"` // Status reported by the database server
}

// serviceCreateOut ServiceCreateResponse
type serviceCreateOut struct {
	Service ServiceCreateOut `json:"service"` // Service information
}

// serviceDatabaseListOut ServiceDatabaseListResponse
type serviceDatabaseListOut struct {
	Databases []DatabaseOut `json:"databases"` // List of databases
}

// serviceEnableWritesOut ServiceEnableWritesResponse
type serviceEnableWritesOut struct {
	Until *string `json:"until,omitempty"` // Writes enabled until
}

// serviceGetOut ServiceGetResponse
type serviceGetOut struct {
	Service ServiceGetOut `json:"service"` // Service information
}

// serviceInfluxDbstatsOut ServiceInfluxDBStatsResponse
type serviceInfluxDbstatsOut struct {
	DbStats map[string]any `json:"db_stats"` // result
}

// serviceKmsGetCaOut ServiceKmsGetCAResponse
type serviceKmsGetCaOut struct {
	Certificate string `json:"certificate"` // PEM encoded certificate
}

// serviceListOut ServiceListResponse
type serviceListOut struct {
	Services []ServiceOut `json:"services"` // List of services under the project
}

// serviceMetricsFetchOut ServiceMetricsFetchResponse
type serviceMetricsFetchOut struct {
	Metrics map[string]any `json:"metrics"` // Service metrics in Google chart compatible format
}

// serviceQueryActivityOut ServiceQueryActivityResponse
type serviceQueryActivityOut struct {
	Queries []QueryOut `json:"queries"` // List of currently running queries and open connections
}

// serviceQueryStatisticsResetOut ServiceQueryStatisticsResetResponse
type serviceQueryStatisticsResetOut struct {
	Queries []map[string]any `json:"queries"` // List of query statistics
}

// serviceTaskCreateOut ServiceTaskCreateResponse
type serviceTaskCreateOut struct {
	Task ServiceTaskCreateOut `json:"task"` // Task info
}

// serviceTaskGetOut ServiceTaskGetResponse
type serviceTaskGetOut struct {
	Task ServiceTaskGetOut `json:"task"` // Task info
}

// serviceUpdateOut ServiceUpdateResponse
type serviceUpdateOut struct {
	Service ServiceUpdateOut `json:"service"` // Service information
}
