// Code generated by Aiven. DO NOT EDIT.

package user

import (
	"context"
	"encoding/json"
	"fmt"
	"net/url"
	"time"
)

type Handler interface {
	// AccessTokenCreate create new access token
	// POST /v1/access_token
	// https://api.aiven.io/doc/#tag/Users/operation/AccessTokenCreate
	AccessTokenCreate(ctx context.Context, in *AccessTokenCreateIn) (*AccessTokenCreateOut, error)

	// AccessTokenList list all valid access tokens
	// GET /v1/access_token
	// https://api.aiven.io/doc/#tag/Users/operation/AccessTokenList
	AccessTokenList(ctx context.Context) ([]TokenOut, error)

	// AccessTokenRevoke revoke an access token
	// DELETE /v1/access_token/{token_prefix}
	// https://api.aiven.io/doc/#tag/Users/operation/AccessTokenRevoke
	AccessTokenRevoke(ctx context.Context, tokenPrefix string) error

	// AccessTokenUpdate update an existing access token
	// PUT /v1/access_token/{token_prefix}
	// https://api.aiven.io/doc/#tag/Users/operation/AccessTokenUpdate
	AccessTokenUpdate(ctx context.Context, tokenPrefix string, in *AccessTokenUpdateIn) (*AccessTokenUpdateOut, error)

	// CheckPasswordStrengthExistingUser check password strength for an existing user
	// POST /v1/me/password_strength
	// https://api.aiven.io/doc/#tag/Users/operation/CheckPasswordStrengthExistingUser
	CheckPasswordStrengthExistingUser(ctx context.Context, in *CheckPasswordStrengthExistingUserIn) (*CheckPasswordStrengthExistingUserOut, error)

	// CheckPasswordStrengthNewUser check password strength for a new user
	// POST /v1/user/password_strength
	// https://api.aiven.io/doc/#tag/Users/operation/CheckPasswordStrengthNewUser
	CheckPasswordStrengthNewUser(ctx context.Context, in *CheckPasswordStrengthNewUserIn) (*CheckPasswordStrengthNewUserOut, error)

	// OrganizationMemberGroupsList list user groups of the organization's member
	// GET /v1/organization/{organization_id}/user/{member_user_id}/user-groups
	// https://api.aiven.io/doc/#tag/Users/operation/OrganizationMemberGroupsList
	OrganizationMemberGroupsList(ctx context.Context, organizationId string, memberUserId string) ([]UserGroupOut, error)

	// TwoFactorAuthConfigure configure two-factor authentication
	// PUT /v1/me/2fa
	// https://api.aiven.io/doc/#tag/Users/operation/TwoFactorAuthConfigure
	TwoFactorAuthConfigure(ctx context.Context, in *TwoFactorAuthConfigureIn) (*TwoFactorAuthConfigureOut, error)

	// TwoFactorAuthConfigureOTP complete one-time password configuration
	// PUT /v1/me/2fa/otp
	// https://api.aiven.io/doc/#tag/Users/operation/TwoFactorAuthConfigureOTP
	TwoFactorAuthConfigureOTP(ctx context.Context, in *TwoFactorAuthConfigureOtpIn) (*TwoFactorAuthConfigureOtpOut, error)

	// UserAccountDelete delete user account
	// DELETE /v1/user/{user_id}
	// https://api.aiven.io/doc/#tag/Users/operation/UserAccountDelete
	UserAccountDelete(ctx context.Context, userId string) error

	// UserAccountInvitesAccept accept all invites for a single account
	// POST /v1/me/account/invites/accept
	// https://api.aiven.io/doc/#tag/Users/operation/UserAccountInvitesAccept
	UserAccountInvitesAccept(ctx context.Context, in *UserAccountInvitesAcceptIn) ([]AccountInviteOut, error)

	// UserAccountInvitesList list pending account invites
	// GET /v1/me/account/invites
	// https://api.aiven.io/doc/#tag/Users/operation/UserAccountInvitesList
	UserAccountInvitesList(ctx context.Context) ([]AccountInviteOut, error)

	// UserAuth authenticate user
	// POST /v1/userauth
	// https://api.aiven.io/doc/#tag/Users/operation/UserAuth
	UserAuth(ctx context.Context, in *UserAuthIn) (*UserAuthOut, error)

	// UserAuthLoginOptions get available login options
	// POST /v1/userauth/login_options
	// https://api.aiven.io/doc/#tag/Users/operation/UserAuthLoginOptions
	UserAuthLoginOptions(ctx context.Context, in *UserAuthLoginOptionsIn) (*UserAuthLoginOptionsOut, error)

	// UserAuthenticationMethodDelete delete linked authentication method, and revoke all associated access tokens
	// DELETE /v1/me/authentication_methods/{user_authentication_method_id}
	// https://api.aiven.io/doc/#tag/Users/operation/UserAuthenticationMethodDelete
	UserAuthenticationMethodDelete(ctx context.Context, userAuthenticationMethodId string) error

	// UserAuthenticationMethodsList list linked authentication methods
	// GET /v1/me/authentication_methods
	// https://api.aiven.io/doc/#tag/Users/operation/UserAuthenticationMethodsList
	UserAuthenticationMethodsList(ctx context.Context) ([]AuthenticationMethodOut, error)

	// Deprecated: UserCreate create a user
	// POST /v1/user
	// https://api.aiven.io/doc/#tag/Users/operation/UserCreate
	UserCreate(ctx context.Context, in *UserCreateIn) (*UserCreateOut, error)

	// UserExpireTokens expire all authorization tokens
	// POST /v1/me/expire_tokens
	// https://api.aiven.io/doc/#tag/Users/operation/UserExpireTokens
	UserExpireTokens(ctx context.Context) error

	// UserInfo get information for the current session's user
	// GET /v1/me
	// https://api.aiven.io/doc/#tag/Users/operation/UserInfo
	UserInfo(ctx context.Context) (*UserInfoOut, error)

	// UserLogout logout user, removing current authentication token
	// POST /v1/me/logout
	// https://api.aiven.io/doc/#tag/Users/operation/UserLogout
	UserLogout(ctx context.Context) error

	// UserPasswordChange change user password
	// PUT /v1/me/password
	// https://api.aiven.io/doc/#tag/Users/operation/UserPasswordChange
	UserPasswordChange(ctx context.Context, in *UserPasswordChangeIn) (string, error)

	// UserPasswordReset confirm user password reset
	// POST /v1/user/password_reset/{verification_code}
	// https://api.aiven.io/doc/#tag/Users/operation/UserPasswordReset
	UserPasswordReset(ctx context.Context, verificationCode string, in *UserPasswordResetIn) error

	// UserPasswordResetRequest request user password reset
	// POST /v1/user/password_reset_request
	// https://api.aiven.io/doc/#tag/Users/operation/UserPasswordResetRequest
	UserPasswordResetRequest(ctx context.Context, in *UserPasswordResetRequestIn) error

	// UserUpdate edit profile
	// PATCH /v1/me
	// https://api.aiven.io/doc/#tag/Users/operation/UserUpdate
	UserUpdate(ctx context.Context, in *UserUpdateIn) (*UserUpdateOut, error)

	// UserVerifyEmail confirm user email address
	// POST /v1/user/verify_email/{verification_code}
	// https://api.aiven.io/doc/#tag/Users/operation/UserVerifyEmail
	UserVerifyEmail(ctx context.Context, verificationCode string) (*UserVerifyEmailOut, error)

	// ValidateCreditCode validate campaign credit code
	// GET /v1/user/credit_code/{credit_code}
	// https://api.aiven.io/doc/#tag/Users/operation/ValidateCreditCode
	ValidateCreditCode(ctx context.Context, creditCode string) error

	// ValidateReferralCode validate referral_code code
	// GET /v1/me/referral/validation/{referral_code}
	// https://api.aiven.io/doc/#tag/Users/operation/ValidateReferralCode
	ValidateReferralCode(ctx context.Context, referralCode string) error
}

// doer http client
type doer interface {
	Do(ctx context.Context, operationID, method, path string, in any, query ...[2]string) ([]byte, error)
}

func NewHandler(doer doer) UserHandler {
	return UserHandler{doer}
}

type UserHandler struct {
	doer doer
}

func (h *UserHandler) AccessTokenCreate(ctx context.Context, in *AccessTokenCreateIn) (*AccessTokenCreateOut, error) {
	path := fmt.Sprintf("/v1/access_token")
	b, err := h.doer.Do(ctx, "AccessTokenCreate", "POST", path, in)
	if err != nil {
		return nil, err
	}
	out := new(AccessTokenCreateOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *UserHandler) AccessTokenList(ctx context.Context) ([]TokenOut, error) {
	path := fmt.Sprintf("/v1/access_token")
	b, err := h.doer.Do(ctx, "AccessTokenList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(accessTokenListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Tokens, nil
}
func (h *UserHandler) AccessTokenRevoke(ctx context.Context, tokenPrefix string) error {
	path := fmt.Sprintf("/v1/access_token/%s", url.PathEscape(tokenPrefix))
	_, err := h.doer.Do(ctx, "AccessTokenRevoke", "DELETE", path, nil)
	return err
}
func (h *UserHandler) AccessTokenUpdate(ctx context.Context, tokenPrefix string, in *AccessTokenUpdateIn) (*AccessTokenUpdateOut, error) {
	path := fmt.Sprintf("/v1/access_token/%s", url.PathEscape(tokenPrefix))
	b, err := h.doer.Do(ctx, "AccessTokenUpdate", "PUT", path, in)
	if err != nil {
		return nil, err
	}
	out := new(AccessTokenUpdateOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *UserHandler) CheckPasswordStrengthExistingUser(ctx context.Context, in *CheckPasswordStrengthExistingUserIn) (*CheckPasswordStrengthExistingUserOut, error) {
	path := fmt.Sprintf("/v1/me/password_strength")
	b, err := h.doer.Do(ctx, "CheckPasswordStrengthExistingUser", "POST", path, in)
	if err != nil {
		return nil, err
	}
	out := new(checkPasswordStrengthExistingUserOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.PasswordStrength, nil
}
func (h *UserHandler) CheckPasswordStrengthNewUser(ctx context.Context, in *CheckPasswordStrengthNewUserIn) (*CheckPasswordStrengthNewUserOut, error) {
	path := fmt.Sprintf("/v1/user/password_strength")
	b, err := h.doer.Do(ctx, "CheckPasswordStrengthNewUser", "POST", path, in)
	if err != nil {
		return nil, err
	}
	out := new(checkPasswordStrengthNewUserOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.PasswordStrength, nil
}
func (h *UserHandler) OrganizationMemberGroupsList(ctx context.Context, organizationId string, memberUserId string) ([]UserGroupOut, error) {
	path := fmt.Sprintf("/v1/organization/%s/user/%s/user-groups", url.PathEscape(organizationId), url.PathEscape(memberUserId))
	b, err := h.doer.Do(ctx, "OrganizationMemberGroupsList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(organizationMemberGroupsListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.UserGroups, nil
}
func (h *UserHandler) TwoFactorAuthConfigure(ctx context.Context, in *TwoFactorAuthConfigureIn) (*TwoFactorAuthConfigureOut, error) {
	path := fmt.Sprintf("/v1/me/2fa")
	b, err := h.doer.Do(ctx, "TwoFactorAuthConfigure", "PUT", path, in)
	if err != nil {
		return nil, err
	}
	out := new(TwoFactorAuthConfigureOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *UserHandler) TwoFactorAuthConfigureOTP(ctx context.Context, in *TwoFactorAuthConfigureOtpIn) (*TwoFactorAuthConfigureOtpOut, error) {
	path := fmt.Sprintf("/v1/me/2fa/otp")
	b, err := h.doer.Do(ctx, "TwoFactorAuthConfigureOTP", "PUT", path, in)
	if err != nil {
		return nil, err
	}
	out := new(TwoFactorAuthConfigureOtpOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *UserHandler) UserAccountDelete(ctx context.Context, userId string) error {
	path := fmt.Sprintf("/v1/user/%s", url.PathEscape(userId))
	_, err := h.doer.Do(ctx, "UserAccountDelete", "DELETE", path, nil)
	return err
}
func (h *UserHandler) UserAccountInvitesAccept(ctx context.Context, in *UserAccountInvitesAcceptIn) ([]AccountInviteOut, error) {
	path := fmt.Sprintf("/v1/me/account/invites/accept")
	b, err := h.doer.Do(ctx, "UserAccountInvitesAccept", "POST", path, in)
	if err != nil {
		return nil, err
	}
	out := new(userAccountInvitesAcceptOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.AccountInvites, nil
}
func (h *UserHandler) UserAccountInvitesList(ctx context.Context) ([]AccountInviteOut, error) {
	path := fmt.Sprintf("/v1/me/account/invites")
	b, err := h.doer.Do(ctx, "UserAccountInvitesList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(userAccountInvitesListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.AccountInvites, nil
}
func (h *UserHandler) UserAuth(ctx context.Context, in *UserAuthIn) (*UserAuthOut, error) {
	path := fmt.Sprintf("/v1/userauth")
	b, err := h.doer.Do(ctx, "UserAuth", "POST", path, in)
	if err != nil {
		return nil, err
	}
	out := new(UserAuthOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *UserHandler) UserAuthLoginOptions(ctx context.Context, in *UserAuthLoginOptionsIn) (*UserAuthLoginOptionsOut, error) {
	path := fmt.Sprintf("/v1/userauth/login_options")
	b, err := h.doer.Do(ctx, "UserAuthLoginOptions", "POST", path, in)
	if err != nil {
		return nil, err
	}
	out := new(UserAuthLoginOptionsOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *UserHandler) UserAuthenticationMethodDelete(ctx context.Context, userAuthenticationMethodId string) error {
	path := fmt.Sprintf("/v1/me/authentication_methods/%s", url.PathEscape(userAuthenticationMethodId))
	_, err := h.doer.Do(ctx, "UserAuthenticationMethodDelete", "DELETE", path, nil)
	return err
}
func (h *UserHandler) UserAuthenticationMethodsList(ctx context.Context) ([]AuthenticationMethodOut, error) {
	path := fmt.Sprintf("/v1/me/authentication_methods")
	b, err := h.doer.Do(ctx, "UserAuthenticationMethodsList", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(userAuthenticationMethodsListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.AuthenticationMethods, nil
}
func (h *UserHandler) UserCreate(ctx context.Context, in *UserCreateIn) (*UserCreateOut, error) {
	path := fmt.Sprintf("/v1/user")
	b, err := h.doer.Do(ctx, "UserCreate", "POST", path, in)
	if err != nil {
		return nil, err
	}
	out := new(UserCreateOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
func (h *UserHandler) UserExpireTokens(ctx context.Context) error {
	path := fmt.Sprintf("/v1/me/expire_tokens")
	_, err := h.doer.Do(ctx, "UserExpireTokens", "POST", path, nil)
	return err
}
func (h *UserHandler) UserInfo(ctx context.Context) (*UserInfoOut, error) {
	path := fmt.Sprintf("/v1/me")
	b, err := h.doer.Do(ctx, "UserInfo", "GET", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(userInfoOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.User, nil
}
func (h *UserHandler) UserLogout(ctx context.Context) error {
	path := fmt.Sprintf("/v1/me/logout")
	_, err := h.doer.Do(ctx, "UserLogout", "POST", path, nil)
	return err
}
func (h *UserHandler) UserPasswordChange(ctx context.Context, in *UserPasswordChangeIn) (string, error) {
	path := fmt.Sprintf("/v1/me/password")
	b, err := h.doer.Do(ctx, "UserPasswordChange", "PUT", path, in)
	if err != nil {
		return "", err
	}
	out := new(userPasswordChangeOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return "", err
	}
	return out.Token, nil
}
func (h *UserHandler) UserPasswordReset(ctx context.Context, verificationCode string, in *UserPasswordResetIn) error {
	path := fmt.Sprintf("/v1/user/password_reset/%s", url.PathEscape(verificationCode))
	_, err := h.doer.Do(ctx, "UserPasswordReset", "POST", path, in)
	return err
}
func (h *UserHandler) UserPasswordResetRequest(ctx context.Context, in *UserPasswordResetRequestIn) error {
	path := fmt.Sprintf("/v1/user/password_reset_request")
	_, err := h.doer.Do(ctx, "UserPasswordResetRequest", "POST", path, in)
	return err
}
func (h *UserHandler) UserUpdate(ctx context.Context, in *UserUpdateIn) (*UserUpdateOut, error) {
	path := fmt.Sprintf("/v1/me")
	b, err := h.doer.Do(ctx, "UserUpdate", "PATCH", path, in)
	if err != nil {
		return nil, err
	}
	out := new(userUpdateOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.User, nil
}
func (h *UserHandler) UserVerifyEmail(ctx context.Context, verificationCode string) (*UserVerifyEmailOut, error) {
	path := fmt.Sprintf("/v1/user/verify_email/%s", url.PathEscape(verificationCode))
	b, err := h.doer.Do(ctx, "UserVerifyEmail", "POST", path, nil)
	if err != nil {
		return nil, err
	}
	out := new(userVerifyEmailOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return &out.InviteDetails, nil
}
func (h *UserHandler) ValidateCreditCode(ctx context.Context, creditCode string) error {
	path := fmt.Sprintf("/v1/user/credit_code/%s", url.PathEscape(creditCode))
	_, err := h.doer.Do(ctx, "ValidateCreditCode", "GET", path, nil)
	return err
}
func (h *UserHandler) ValidateReferralCode(ctx context.Context, referralCode string) error {
	path := fmt.Sprintf("/v1/me/referral/validation/%s", url.PathEscape(referralCode))
	_, err := h.doer.Do(ctx, "ValidateReferralCode", "GET", path, nil)
	return err
}

// AccessTokenCreateIn AccessTokenCreateRequestBody
type AccessTokenCreateIn struct {
	Description    string    `json:"description"`                // Name / description of an access token
	ExtendWhenUsed *bool     `json:"extend_when_used,omitempty"` // Extend token expiration time when token is used. Only applicable if max_age_seconds is specified.
	MaxAgeSeconds  *float64  `json:"max_age_seconds,omitempty"`  // Time the token remains valid since creation (or since last use if extend_when_used is true)
	Scopes         *[]string `json:"scopes,omitempty"`           // Scopes this token is restricted to, if specified
}

// AccessTokenCreateOut AccessTokenCreateResponse
type AccessTokenCreateOut struct {
	CreateTime                 time.Time  `json:"create_time"`                              // Timestamp when the access token was created
	CreatedManually            bool       `json:"created_manually"`                         // True for tokens explicitly created via the access_tokens API, false for tokens created via login.
	CurrentlyActive            *bool      `json:"currently_active,omitempty"`               // true if API request was made with this access token
	Description                *string    `json:"description,omitempty"`                    // Name / description of an access token
	ExpiryTime                 *time.Time `json:"expiry_time,omitempty"`                    // Timestamp when the access token will expire unless extended, if ever
	ExtendWhenUsed             bool       `json:"extend_when_used"`                         // Extend token expiration time when token is used. Only applicable if max_age_seconds is specified.
	FullToken                  string     `json:"full_token"`                               // This full access token can be used to make API calls. This can also be used to update or revoke tokens. Note that when using this token with the update and revoke APIs it must be URL encoded because it may contain /, + and = characters (/ =&gt; %2F, + =&gt; %2B, = =&gt; %3D).
	LastIp                     *string    `json:"last_ip,omitempty"`                        // IP address the access token was last used from in case it has ever been used
	LastUsedTime               *time.Time `json:"last_used_time,omitempty"`                 // Timestamp when the access token was last used, if ever
	LastUserAgent              *string    `json:"last_user_agent,omitempty"`                // User agent string of the client that last used the token in case it has ever been used
	LastUserAgentHumanReadable *string    `json:"last_user_agent_human_readable,omitempty"` // Human readable user agent string of the client that last used the token in case user agent is known
	MaxAgeSeconds              float64    `json:"max_age_seconds"`                          // Time the token remains valid since creation (or since last use if extend_when_used is true)
	Scopes                     []string   `json:"scopes,omitempty"`                         // Scopes this token is restricted to, if specified
	TokenPrefix                string     `json:"token_prefix"`                             // First characters of the actual token value. Full value is only exposed after creation. This value is used when updating or revoking tokens. Note that the value may contain /, + and = characters and must be URL encoded when used (/ =&gt; %2F, + =&gt; %2B, = =&gt; %3D).
}

// AccessTokenUpdateIn AccessTokenUpdateRequestBody
type AccessTokenUpdateIn struct {
	Description string `json:"description"` // Name / description of an access token
}

// AccessTokenUpdateOut AccessTokenUpdateResponse
type AccessTokenUpdateOut struct {
	CreateTime                 time.Time  `json:"create_time"`                              // Timestamp when the access token was created
	CreatedManually            *bool      `json:"created_manually,omitempty"`               // True for tokens explicitly created via the access_tokens API, false for tokens created via login.
	CurrentlyActive            *bool      `json:"currently_active,omitempty"`               // true if API request was made with this access token
	Description                *string    `json:"description,omitempty"`                    // Name / description of an access token
	ExpiryTime                 *time.Time `json:"expiry_time,omitempty"`                    // Timestamp when the access token will expire unless extended, if ever
	ExtendWhenUsed             bool       `json:"extend_when_used"`                         // Extend token expiration time when token is used. Only applicable if max_age_seconds is specified.
	LastIp                     *string    `json:"last_ip,omitempty"`                        // IP address the access token was last used from in case it has ever been used
	LastUsedTime               *time.Time `json:"last_used_time,omitempty"`                 // Timestamp when the access token was last used, if ever
	LastUserAgent              *string    `json:"last_user_agent,omitempty"`                // User agent string of the client that last used the token in case it has ever been used
	LastUserAgentHumanReadable *string    `json:"last_user_agent_human_readable,omitempty"` // Human readable user agent string of the client that last used the token in case user agent is known
	MaxAgeSeconds              float64    `json:"max_age_seconds"`                          // Time the token remains valid since creation (or since last use if extend_when_used is true)
	Scopes                     []string   `json:"scopes,omitempty"`                         // Scopes this token is restricted to, if specified
	TokenPrefix                string     `json:"token_prefix"`                             // First characters of the actual token value. Full value is only exposed after creation. This value is used when updating or revoking tokens. Note that the value may contain /, + and = characters and must be URL encoded when used (/ =&gt; %2F, + =&gt; %2B, = =&gt; %3D).
}
type AccountInviteOut struct {
	AccountId          string    `json:"account_id"`            // Account ID
	AccountName        string    `json:"account_name"`          // Account name
	CreateTime         time.Time `json:"create_time"`           // Timestamp in ISO 8601 format, always in UTC
	InvitedByUserEmail string    `json:"invited_by_user_email"` // User email address
	TeamId             string    `json:"team_id"`               // Team ID
	TeamName           string    `json:"team_name"`             // Team name
	UserEmail          string    `json:"user_email"`            // User email address
}
type ActionType string

const (
	ActionTypeAzureOauth  ActionType = "azure_oauth"
	ActionTypeGithubOauth ActionType = "github_oauth"
	ActionTypeGoogleOauth ActionType = "google_oauth"
	ActionTypeHasuraOauth ActionType = "hasura_oauth"
	ActionTypePassword    ActionType = "password"
	ActionTypeSaml        ActionType = "saml"
	ActionTypeSignup      ActionType = "signup"
)

func ActionTypeChoices() []string {
	return []string{"azure_oauth", "github_oauth", "google_oauth", "hasura_oauth", "password", "saml", "signup"}
}

type AnyType string

const (
	AnyTypeAdmin     AnyType = "admin"
	AnyTypeDeveloper AnyType = "developer"
	AnyTypeOperator  AnyType = "operator"
	AnyTypeReadOnly  AnyType = "read_only"
)

func AnyTypeChoices() []string {
	return []string{"admin", "developer", "operator", "read_only"}
}

type AuthenticationMethodOut struct {
	AuthenticationMethodAccountId string                        `json:"authentication_method_account_id"` // Account ID
	CreateTime                    time.Time                     `json:"create_time"`                      // Timestamp in ISO 8601 format, always in UTC
	CurrentlyActive               bool                          `json:"currently_active"`                 // true if API was accessed with this authentication method
	DeleteTime                    time.Time                     `json:"delete_time"`                      // Timestamp in ISO 8601 format, always in UTC
	LastUsedTime                  time.Time                     `json:"last_used_time"`                   // Timestamp in ISO 8601 format, always in UTC
	MethodId                      string                        `json:"method_id"`                        // Unique ID for authentication method
	Name                          *string                       `json:"name,omitempty"`                   // Authentication method name
	PublicRemoteIdentity          string                        `json:"public_remote_identity"`           // Identity on remote provider, if available. May be email address, but not necessarily.
	RemoteProviderId              string                        `json:"remote_provider_id"`               // Provider ID
	State                         AuthenticationMethodStateType `json:"state"`                            // State for authentication method
	UpdateTime                    time.Time                     `json:"update_time"`                      // Timestamp in ISO 8601 format, always in UTC
	UserEmail                     string                        `json:"user_email"`                       // User email address
}
type AuthenticationMethodStateType string

const (
	AuthenticationMethodStateTypeActive  AuthenticationMethodStateType = "active"
	AuthenticationMethodStateTypeDeleted AuthenticationMethodStateType = "deleted"
)

func AuthenticationMethodStateTypeChoices() []string {
	return []string{"active", "deleted"}
}

// CheckPasswordStrengthExistingUserIn CheckPasswordStrengthExistingUserRequestBody
type CheckPasswordStrengthExistingUserIn struct {
	NewPassword string `json:"new_password"` // New password
	OldPassword string `json:"old_password"` // User password
}

// CheckPasswordStrengthExistingUserOut Password strength
type CheckPasswordStrengthExistingUserOut struct {
	IsAcceptable *bool  `json:"is_acceptable,omitempty"` // True if the password is acceptable
	Message      string `json:"message"`                 // Password strength message
	Score        int    `json:"score"`                   // Password strength score
}

// CheckPasswordStrengthNewUserIn CheckPasswordStrengthNewUserRequestBody
type CheckPasswordStrengthNewUserIn struct {
	Email    *string `json:"email,omitempty"`     // User email address
	Password string  `json:"password"`            // New password
	RealName *string `json:"real_name,omitempty"` // User real name
}

// CheckPasswordStrengthNewUserOut Password strength
type CheckPasswordStrengthNewUserOut struct {
	IsAcceptable *bool  `json:"is_acceptable,omitempty"` // True if the password is acceptable
	Message      string `json:"message"`                 // Password strength message
	Score        int    `json:"score"`                   // Password strength score
}
type InvitationOut struct {
	InviteCode        string    `json:"invite_code"`         // Code for accepting the invitation
	InviteTime        time.Time `json:"invite_time"`         // Timestamp in ISO 8601 format, always in UTC
	InvitingUserEmail string    `json:"inviting_user_email"` // User email address
	ProjectName       string    `json:"project_name"`        // Project name
}
type MethodType string

const (
	MethodTypePost MethodType = "POST"
	MethodTypeGet  MethodType = "GET"
)

func MethodTypeChoices() []string {
	return []string{"POST", "GET"}
}

// ProjectMembershipOut Project membership and type of membership
type ProjectMembershipOut struct {
	Any AnyType `json:"ANY,omitempty"` // Project member type
}

// ProjectMembershipsOut List of project membership and type of membership
type ProjectMembershipsOut struct {
	Any []string `json:"ANY,omitempty"` // List of project member type
}
type TokenOut struct {
	CreateTime                 time.Time  `json:"create_time"`                              // Timestamp when the access token was created
	CreatedManually            bool       `json:"created_manually"`                         // True for tokens explicitly created via the access_tokens API, false for tokens created via login.
	CurrentlyActive            *bool      `json:"currently_active,omitempty"`               // true if API request was made with this access token
	Description                *string    `json:"description,omitempty"`                    // Name / description of an access token
	ExpiryTime                 *time.Time `json:"expiry_time,omitempty"`                    // Timestamp when the access token will expire unless extended, if ever
	ExtendWhenUsed             bool       `json:"extend_when_used"`                         // Extend token expiration time when token is used. Only applicable if max_age_seconds is specified.
	LastIp                     *string    `json:"last_ip,omitempty"`                        // IP address the access token was last used from in case it has ever been used
	LastUsedTime               *time.Time `json:"last_used_time,omitempty"`                 // Timestamp when the access token was last used, if ever
	LastUserAgent              *string    `json:"last_user_agent,omitempty"`                // User agent string of the client that last used the token in case it has ever been used
	LastUserAgentHumanReadable *string    `json:"last_user_agent_human_readable,omitempty"` // Human readable user agent string of the client that last used the token in case user agent is known
	MaxAgeSeconds              float64    `json:"max_age_seconds"`                          // Time the token remains valid since creation (or since last use if extend_when_used is true)
	Scopes                     []string   `json:"scopes,omitempty"`                         // Scopes this token is restricted to, if specified
	TokenPrefix                string     `json:"token_prefix"`                             // First characters of the actual token value. Full value is only exposed after creation. This value is used when updating or revoking tokens. Note that the value may contain /, + and = characters and must be URL encoded when used (/ =&gt; %2F, + =&gt; %2B, = =&gt; %3D).
}

// TwoFactorAuthConfigureIn TwoFactorAuthConfigureRequestBody
type TwoFactorAuthConfigureIn struct {
	Method   string `json:"method"`   // Two-factor authentication method being used, if any
	Password string `json:"password"` // Current password
}

// TwoFactorAuthConfigureOtpIn TwoFactorAuthConfigureOTPRequestBody
type TwoFactorAuthConfigureOtpIn struct {
	Otp      string `json:"otp"`      // One-time password
	Password string `json:"password"` // Current password
	Uri      string `json:"uri"`      // URI describing the TOTP
}

// TwoFactorAuthConfigureOtpOut TwoFactorAuthConfigureOTPResponse
type TwoFactorAuthConfigureOtpOut struct {
	Method string `json:"method"` // Two-factor authentication method being used, if any
	Token  string `json:"token"`  // New API session authentication token when configuration is complete
}

// TwoFactorAuthConfigureOut TwoFactorAuthConfigureResponse
type TwoFactorAuthConfigureOut struct {
	Method string  `json:"method"`           // Two-factor authentication method being used, if any
	Qrcode *string `json:"qrcode,omitempty"` // QR code describing the TOTP as a base64-encoded PNG
	Uri    *string `json:"uri,omitempty"`    // URI describing the TOTP
}

// UserAccountInvitesAcceptIn UserAccountInvitesAcceptRequestBody
type UserAccountInvitesAcceptIn struct {
	AccountId string  `json:"account_id"`        // Account ID
	TeamId    *string `json:"team_id,omitempty"` // Team ID
}

// UserAuthIn UserAuthRequestBody
type UserAuthIn struct {
	Email    string  `json:"email"`         // User email address
	Otp      *string `json:"otp,omitempty"` // One-time password
	Password string  `json:"password"`      // User password
}

// UserAuthLoginOptionsIn UserAuthLoginOptionsRequestBody
type UserAuthLoginOptionsIn struct {
	Email *string `json:"email,omitempty"` // User email address
}

// UserAuthLoginOptionsOut UserAuthLoginOptionsResponse
type UserAuthLoginOptionsOut struct {
	None        []map[string]any `json:"None,omitempty"`         // List of available login methods
	Action      ActionType       `json:"action"`                 // Action
	Method      MethodType       `json:"method,omitempty"`       // HTTP method used for redirecting
	Name        *string          `json:"name,omitempty"`         // Human readable name
	RedirectUrl *string          `json:"redirect_url,omitempty"` // Redirect URL for signing in
}

// UserAuthOut UserAuthResponse
type UserAuthOut struct {
	ReturnUrl *string `json:"return_url,omitempty"` // Return URL
	State     string  `json:"state"`                // User account state
	Token     string  `json:"token"`                // API session authentication token
	UserEmail string  `json:"user_email"`           // User email address
}

// UserCreateIn UserCreateRequestBody
type UserCreateIn struct {
	Company                      *string   `json:"company,omitempty"`                        // Name of a company
	CountryCode                  *string   `json:"country_code,omitempty"`                   // Two letter country code for country
	CreditCode                   *string   `json:"credit_code,omitempty"`                    // Credit code
	Email                        string    `json:"email"`                                    // User email address
	EmailCommunicationCategories *[]string `json:"email_communication_categories,omitempty"` // Categories of email communication enabled for user during signup
	Origin                       *string   `json:"origin,omitempty"`                         // Origin of the user
	Password                     *string   `json:"password,omitempty"`                       // User password
	RealName                     string    `json:"real_name"`                                // User real name
	State                        *string   `json:"state,omitempty"`                          // Address state
	Token                        *string   `json:"token,omitempty"`                          // Signup token for single sign-on linking
}

// UserCreateOut UserCreateResponse
type UserCreateOut struct {
	State     string  `json:"state"`      // User account state
	Token     string  `json:"token"`      // API session authentication token
	User      UserOut `json:"user"`       // User information
	UserEmail string  `json:"user_email"` // User email address
}
type UserGroupOut struct {
	CreateTime    time.Time `json:"create_time"` // User group creation time
	Description   string    `json:"description"`
	ManagedByScim bool      `json:"managed_by_scim"` // Managed By Scim
	UpdateTime    time.Time `json:"update_time"`     // User group last update time
	UserGroupId   string    `json:"user_group_id"`   // User Group ID
	UserGroupName string    `json:"user_group_name"` // User Group Name
}

// UserInfoOut User information
type UserInfoOut struct {
	Auth                   []string               `json:"auth"` // List of user's required authentication methods
	City                   *string                `json:"city,omitempty"`
	Country                *string                `json:"country,omitempty"`                  // Country code ISO 3166-1 alpha-2
	CreateTime             *time.Time             `json:"create_time,omitempty"`              // User registration time
	Department             *string                `json:"department,omitempty"`               // Job department
	Features               map[string]any         `json:"features,omitempty"`                 // Feature flags
	Invitations            []InvitationOut        `json:"invitations"`                        // List of pending invitations
	JobTitle               *string                `json:"job_title,omitempty"`                // Job title
	ManagedByScim          *bool                  `json:"managed_by_scim,omitempty"`          // User management status
	ManagingOrganizationId *string                `json:"managing_organization_id,omitempty"` // Organization ID
	ProjectMembership      ProjectMembershipOut   `json:"project_membership"`                 // Project membership and type of membership
	ProjectMemberships     *ProjectMembershipsOut `json:"project_memberships,omitempty"`      // List of project membership and type of membership
	Projects               []string               `json:"projects"`                           // List of projects the user is a member of
	RealName               string                 `json:"real_name"`                          // User real name
	State                  string                 `json:"state"`                              // User account state
	TokenValidityBegin     *string                `json:"token_validity_begin,omitempty"`     // Earliest valid authentication token timestamp
	User                   string                 `json:"user"`                               // User email address
	UserId                 string                 `json:"user_id"`                            // User ID
}

// UserOut User information
type UserOut struct {
	Auth                   []string               `json:"auth"` // List of user's required authentication methods
	City                   *string                `json:"city,omitempty"`
	Country                *string                `json:"country,omitempty"`                  // Country code ISO 3166-1 alpha-2
	CreateTime             *time.Time             `json:"create_time,omitempty"`              // User registration time
	Department             *string                `json:"department,omitempty"`               // Job department
	Features               map[string]any         `json:"features,omitempty"`                 // Feature flags
	Invitations            []InvitationOut        `json:"invitations"`                        // List of pending invitations
	JobTitle               *string                `json:"job_title,omitempty"`                // Job title
	ManagedByScim          *bool                  `json:"managed_by_scim,omitempty"`          // User management status
	ManagingOrganizationId *string                `json:"managing_organization_id,omitempty"` // Organization ID
	ProjectMembership      ProjectMembershipOut   `json:"project_membership"`                 // Project membership and type of membership
	ProjectMemberships     *ProjectMembershipsOut `json:"project_memberships,omitempty"`      // List of project membership and type of membership
	Projects               []string               `json:"projects"`                           // List of projects the user is a member of
	RealName               string                 `json:"real_name"`                          // User real name
	State                  string                 `json:"state"`                              // User account state
	TokenValidityBegin     *string                `json:"token_validity_begin,omitempty"`     // Earliest valid authentication token timestamp
	User                   string                 `json:"user"`                               // User email address
	UserId                 string                 `json:"user_id"`                            // User ID
}

// UserPasswordChangeIn UserPasswordChangeRequestBody
type UserPasswordChangeIn struct {
	NewPassword string `json:"new_password"` // New password
	Password    string `json:"password"`     // Current password
}

// UserPasswordResetIn UserPasswordResetRequestBody
type UserPasswordResetIn struct {
	NewPassword string `json:"new_password"` // New password
}

// UserPasswordResetRequestIn UserPasswordResetRequestRequestBody
type UserPasswordResetRequestIn struct {
	Email string `json:"email"` // User email address
}

// UserUpdateIn UserUpdateRequestBody
type UserUpdateIn struct {
	City       *string `json:"city,omitempty"`
	Country    *string `json:"country,omitempty"`    // Country code ISO 3166-1 alpha-2
	Department *string `json:"department,omitempty"` // Job department
	JobTitle   *string `json:"job_title,omitempty"`  // Job title
	RealName   string  `json:"real_name"`            // User real name
}

// UserUpdateOut User information
type UserUpdateOut struct {
	Auth                   []string               `json:"auth"` // List of user's required authentication methods
	City                   *string                `json:"city,omitempty"`
	Country                *string                `json:"country,omitempty"`                  // Country code ISO 3166-1 alpha-2
	CreateTime             *time.Time             `json:"create_time,omitempty"`              // User registration time
	Department             *string                `json:"department,omitempty"`               // Job department
	Features               map[string]any         `json:"features,omitempty"`                 // Feature flags
	Invitations            []InvitationOut        `json:"invitations"`                        // List of pending invitations
	JobTitle               *string                `json:"job_title,omitempty"`                // Job title
	ManagedByScim          *bool                  `json:"managed_by_scim,omitempty"`          // User management status
	ManagingOrganizationId *string                `json:"managing_organization_id,omitempty"` // Organization ID
	ProjectMembership      ProjectMembershipOut   `json:"project_membership"`                 // Project membership and type of membership
	ProjectMemberships     *ProjectMembershipsOut `json:"project_memberships,omitempty"`      // List of project membership and type of membership
	Projects               []string               `json:"projects"`                           // List of projects the user is a member of
	RealName               string                 `json:"real_name"`                          // User real name
	State                  string                 `json:"state"`                              // User account state
	TokenValidityBegin     *string                `json:"token_validity_begin,omitempty"`     // Earliest valid authentication token timestamp
	User                   string                 `json:"user"`                               // User email address
	UserId                 string                 `json:"user_id"`                            // User ID
}

// UserVerifyEmailOut Details of verified invite
type UserVerifyEmailOut struct {
	UserEmail string `json:"user_email"` // User email address
}

// accessTokenListOut AccessTokenListResponse
type accessTokenListOut struct {
	Tokens []TokenOut `json:"tokens"` // List of access tokens
}

// checkPasswordStrengthExistingUserOut CheckPasswordStrengthExistingUserResponse
type checkPasswordStrengthExistingUserOut struct {
	PasswordStrength CheckPasswordStrengthExistingUserOut `json:"password_strength"` // Password strength
}

// checkPasswordStrengthNewUserOut CheckPasswordStrengthNewUserResponse
type checkPasswordStrengthNewUserOut struct {
	PasswordStrength CheckPasswordStrengthNewUserOut `json:"password_strength"` // Password strength
}

// organizationMemberGroupsListOut OrganizationMemberGroupsListResponse
type organizationMemberGroupsListOut struct {
	UserGroups []UserGroupOut `json:"user_groups"` // User Groups
}

// userAccountInvitesAcceptOut UserAccountInvitesAcceptResponse
type userAccountInvitesAcceptOut struct {
	AccountInvites []AccountInviteOut `json:"account_invites"` // List of invites
}

// userAccountInvitesListOut UserAccountInvitesListResponse
type userAccountInvitesListOut struct {
	AccountInvites []AccountInviteOut `json:"account_invites"` // List of invites
}

// userAuthenticationMethodsListOut UserAuthenticationMethodsListResponse
type userAuthenticationMethodsListOut struct {
	AuthenticationMethods []AuthenticationMethodOut `json:"authentication_methods"` // List of linked authentication methods
}

// userInfoOut UserInfoResponse
type userInfoOut struct {
	User UserInfoOut `json:"user"` // User information
}

// userPasswordChangeOut UserPasswordChangeResponse
type userPasswordChangeOut struct {
	Token string `json:"token"` // API session authentication token
}

// userUpdateOut UserUpdateResponse
type userUpdateOut struct {
	User UserUpdateOut `json:"user"` // User information
}

// userVerifyEmailOut UserVerifyEmailResponse
type userVerifyEmailOut struct {
	InviteDetails UserVerifyEmailOut `json:"invite_details"` // Details of verified invite
}
